<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giddy.markov &#8212; giddy v2.3.3 Manual</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pysal-styles.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          giddy</a>
        <span class="navbar-text navbar-version pull-left"><b>2.3.3</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../installation.html">Installation</a></li>
                <li><a href="../../tutorial.html">Tutorial</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-released-version">Installing released version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-development-version">Installing development version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../MarkovBasedMethods.html">Spatially Explicit Markov Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../RankMarkov.html">Full Rank Markov and Geographic Rank Markov</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../MobilityMeasures.html">Measures of Income Mobility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../DirectionalLISA.html">Directional Analysis of Dynamic LISAs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../RankBasedMethods.html">Rank based Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Sequence.html">Alignment-based sequence methods</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#markov-methods">Markov Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#directional-lisa">Directional LISA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#economic-mobility-indices">Economic Mobility Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#exchange-mobility-methods">Exchange Mobility Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#alignment-based-sequence-methods">Alignment-based Sequence Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#utility-functions">Utility Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for giddy.markov</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Markov based methods for spatial dynamics.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Sergio J. Rey &lt;sjsrey@gmail.com&gt;, Wei Kang &lt;weikang9009@gmail.com&gt;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Markov&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LISA_Markov&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Spatial_Markov&quot;</span><span class="p">,</span>
    <span class="s2">&quot;kullback&quot;</span><span class="p">,</span>
    <span class="s2">&quot;prais&quot;</span><span class="p">,</span>
    <span class="s2">&quot;homogeneity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FullRank_Markov&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sojourn_time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GeoRank_Markov&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.ergodic</span> <span class="kn">import</span> <span class="n">steady_state</span><span class="p">,</span> <span class="n">fmpt</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">fill_empty_diagonals</span>
<span class="kn">from</span> <span class="nn">.components</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">gt</span>
<span class="kn">from</span> <span class="nn">libpysal</span> <span class="kn">import</span> <span class="n">weights</span>
<span class="kn">from</span> <span class="nn">esda.moran</span> <span class="kn">import</span> <span class="n">Moran_Local</span>
<span class="kn">import</span> <span class="nn">mapclassify</span> <span class="k">as</span> <span class="nn">mc</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">quantecon</span> <span class="k">as</span> <span class="nn">qe</span>

<span class="c1"># TT predefine LISA transitions</span>
<span class="c1"># TT[i,j] is the transition type from i to j</span>
<span class="c1"># i = quadrant in period 0</span>
<span class="c1"># j = quadrant in period 1</span>
<span class="c1"># uses one offset so first row and col of TT are ignored</span>
<span class="n">TT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">TT</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># MOVE_TYPES is a dictionary that returns the move type of a LISA transition</span>
<span class="c1"># filtered on the significance of the LISA end points</span>
<span class="c1"># True indicates significant LISA in a particular period</span>
<span class="c1"># e.g. a key of (1, 3, True, False) indicates a significant LISA located in</span>
<span class="c1"># quadrant 1 in period 0 moved to quadrant 3 in period 1 but was not</span>
<span class="c1"># significant in quadrant 3.</span>

<span class="n">MOVE_TYPES</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">cases</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">sig_keys</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cases</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sig_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig_keys</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">16</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sig_key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sig_key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">MOVE_TYPES</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>


<div class="viewcode-block" id="Markov"><a class="viewcode-back" href="../../generated/giddy.markov.Markov.html#giddy.markov.Markov">[docs]</a><span class="k">class</span> <span class="nc">Markov</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classic Markov Chain estimation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    class_ids    : array</span>
<span class="sd">                   (n, t), one row per observation, one column recording the</span>
<span class="sd">                   state of each observation, with as many columns as time</span>
<span class="sd">                   periods.</span>
<span class="sd">    classes      : array</span>
<span class="sd">                   (k, 1), all different classes (bins) of the matrix.</span>
<span class="sd">    fill_empty_classes: bool</span>
<span class="sd">                        If True, assign 1 to diagonal elements which fall in rows</span>
<span class="sd">                        full of 0s to ensure p is a stochastic transition</span>
<span class="sd">                        probability matrix (each row sums up to 1).</span>
<span class="sd">    summary      : bool</span>
<span class="sd">                   If True, print out the summary of the Markov Chain during</span>
<span class="sd">                   initialization. Default is True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    k            : int</span>
<span class="sd">                   Number of Markov states.</span>
<span class="sd">    p            : array</span>
<span class="sd">                   (k, k), transition probability matrix.</span>
<span class="sd">    num_cclasses : int</span>
<span class="sd">                   Number of communicating classes.</span>
<span class="sd">    cclasses_indices : list</span>
<span class="sd">                       List of indices within each communicating classes.</span>
<span class="sd">    num_rclasses : int</span>
<span class="sd">                   Number of recurrent classes.</span>
<span class="sd">    rclasses_indices : list</span>
<span class="sd">                       List of indices within each recurrent classes.</span>
<span class="sd">    num_astates  : int</span>
<span class="sd">                   Number of absorbing states.</span>
<span class="sd">    astates_indices  : list</span>
<span class="sd">                       List of indices of absorbing states.</span>
<span class="sd">    steady_state : array</span>
<span class="sd">                   Steady state distributions. If the Markov chain only has</span>
<span class="sd">                   one recurrent class (num_rclasses=1), it will converge to</span>
<span class="sd">                   an unique distribution in the long run, and thus steady_state</span>
<span class="sd">                   is of (k, ) dimension; if the Markov chain has multiple</span>
<span class="sd">                   recurrent classes (num_rclasses&gt;1), there will be</span>
<span class="sd">                   (num_rclasses) steady state distributions and steady_state</span>
<span class="sd">                   will be of (num_rclasses, k) dimension.</span>
<span class="sd">    transitions  : array</span>
<span class="sd">                   (k, k), count of transitions between each state i and j.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from giddy.markov import Markov</span>
<span class="sd">    &gt;&gt;&gt; c = [[&#39;b&#39;,&#39;a&#39;,&#39;c&#39;],[&#39;c&#39;,&#39;c&#39;,&#39;a&#39;],[&#39;c&#39;,&#39;b&#39;,&#39;c&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; c.extend([[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;], [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]])</span>
<span class="sd">    &gt;&gt;&gt; c = np.array(c)</span>
<span class="sd">    &gt;&gt;&gt; m = Markov(c)</span>
<span class="sd">    The Markov Chain is irreducible and is composed by:</span>
<span class="sd">    1 Recurrent class (indices):</span>
<span class="sd">    [0 1 2]</span>
<span class="sd">    0 Transient classes.</span>
<span class="sd">    The Markov Chain has 0 absorbing states.</span>
<span class="sd">    &gt;&gt;&gt; m.classes.tolist()</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; m.p</span>
<span class="sd">    array([[0.25      , 0.5       , 0.25      ],</span>
<span class="sd">           [0.33333333, 0.        , 0.66666667],</span>
<span class="sd">           [0.33333333, 0.33333333, 0.33333333]])</span>
<span class="sd">    &gt;&gt;&gt; m.steady_state</span>
<span class="sd">    array([0.30769231, 0.28846154, 0.40384615])</span>

<span class="sd">    Reducible Markov chain</span>

<span class="sd">    &gt;&gt;&gt; c = [[&#39;b&#39;,&#39;a&#39;,&#39;a&#39;],[&#39;c&#39;,&#39;c&#39;,&#39;a&#39;],[&#39;c&#39;,&#39;b&#39;,&#39;c&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; m = Markov(c)</span>
<span class="sd">    The Markov Chain is reducible and is composed by:</span>
<span class="sd">    1 Recurrent class (indices):</span>
<span class="sd">    [0]</span>
<span class="sd">    1 Transient class (indices):</span>
<span class="sd">    [1 2]</span>
<span class="sd">    The Markov Chain has 1 absorbing state (index):</span>
<span class="sd">    [0]</span>

<span class="sd">    US nominal per capita income 48 states 81 years 1929-2009</span>

<span class="sd">    &gt;&gt;&gt; import libpysal</span>
<span class="sd">    &gt;&gt;&gt; import mapclassify as mc</span>
<span class="sd">    &gt;&gt;&gt; f = libpysal.io.open(libpysal.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">    &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in range(1929,2010)])</span>

<span class="sd">    set classes to quintiles for each year</span>

<span class="sd">    &gt;&gt;&gt; q5 = np.array([mc.Quantiles(y).yb for y in pci]).transpose()</span>
<span class="sd">    &gt;&gt;&gt; m = Markov(q5)</span>
<span class="sd">    The Markov Chain is irreducible and is composed by:</span>
<span class="sd">    1 Recurrent class (indices):</span>
<span class="sd">    [0 1 2 3 4]</span>
<span class="sd">    0 Transient classes.</span>
<span class="sd">    The Markov Chain has 0 absorbing states.</span>
<span class="sd">    &gt;&gt;&gt; m.transitions</span>
<span class="sd">    array([[729.,  71.,   1.,   0.,   0.],</span>
<span class="sd">           [ 72., 567.,  80.,   3.,   0.],</span>
<span class="sd">           [  0.,  81., 631.,  86.,   2.],</span>
<span class="sd">           [  0.,   3.,  86., 573.,  56.],</span>
<span class="sd">           [  0.,   0.,   1.,  57., 741.]])</span>
<span class="sd">    &gt;&gt;&gt; m.p</span>
<span class="sd">    array([[0.91011236, 0.0886392 , 0.00124844, 0.        , 0.        ],</span>
<span class="sd">           [0.09972299, 0.78531856, 0.11080332, 0.00415512, 0.        ],</span>
<span class="sd">           [0.        , 0.10125   , 0.78875   , 0.1075    , 0.0025    ],</span>
<span class="sd">           [0.        , 0.00417827, 0.11977716, 0.79805014, 0.07799443],</span>
<span class="sd">           [0.        , 0.        , 0.00125156, 0.07133917, 0.92740926]])</span>
<span class="sd">    &gt;&gt;&gt; m.steady_state</span>
<span class="sd">    array([0.20774716, 0.18725774, 0.20740537, 0.18821787, 0.20937187])</span>

<span class="sd">    Relative incomes</span>

<span class="sd">    &gt;&gt;&gt; pci = pci.transpose()</span>
<span class="sd">    &gt;&gt;&gt; rpci = pci/(pci.mean(axis=0))</span>
<span class="sd">    &gt;&gt;&gt; rq = mc.Quantiles(rpci.flatten()).yb.reshape(pci.shape)</span>
<span class="sd">    &gt;&gt;&gt; mq = Markov(rq)</span>
<span class="sd">    The Markov Chain is irreducible and is composed by:</span>
<span class="sd">    1 Recurrent class (indices):</span>
<span class="sd">    [0 1 2 3 4]</span>
<span class="sd">    0 Transient classes.</span>
<span class="sd">    The Markov Chain has 0 absorbing states.</span>
<span class="sd">    &gt;&gt;&gt; mq.transitions</span>
<span class="sd">    array([[707.,  58.,   7.,   1.,   0.],</span>
<span class="sd">           [ 50., 629.,  80.,   1.,   1.],</span>
<span class="sd">           [  4.,  79., 610.,  73.,   2.],</span>
<span class="sd">           [  0.,   7.,  72., 650.,  37.],</span>
<span class="sd">           [  0.,   0.,   0.,  48., 724.]])</span>
<span class="sd">    &gt;&gt;&gt; mq.steady_state</span>
<span class="sd">    array([0.17957376, 0.21631443, 0.21499942, 0.21134662, 0.17776576])</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Markov.__init__"><a class="viewcode-back" href="../../generated/giddy.markov.Markov.html#giddy.markov.Markov.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_ids</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">classes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">class_ids</span><span class="p">)</span>

        <span class="n">class_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">class_ids</span><span class="p">)</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">class_ids</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">js</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">classIds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">state_0</span> <span class="ow">in</span> <span class="n">js</span><span class="p">:</span>
            <span class="n">state_1</span> <span class="o">=</span> <span class="n">state_0</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">state_0</span> <span class="o">=</span> <span class="n">class_ids</span><span class="p">[:,</span> <span class="n">state_0</span><span class="p">]</span>
            <span class="n">state_1</span> <span class="o">=</span> <span class="n">class_ids</span><span class="p">[:,</span> <span class="n">state_1</span><span class="p">]</span>
            <span class="n">initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">state_0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">initial</span><span class="p">:</span>
                <span class="n">ending</span> <span class="o">=</span> <span class="n">state_1</span><span class="p">[</span><span class="n">state_0</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">uending</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ending</span><span class="p">)</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">classIds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">uending</span><span class="p">:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">classIds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ending</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="n">transitions</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="n">transitions</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">row_sum</span> <span class="o">+</span> <span class="p">(</span><span class="n">row_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))),</span> <span class="n">transitions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fill_empty_classes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">fill_empty_diagonals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

        <span class="n">p_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p_temp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p_temp</span> <span class="o">=</span> <span class="n">fill_empty_diagonals</span><span class="p">(</span><span class="n">p_temp</span><span class="p">)</span>
        <span class="n">markovchain</span> <span class="o">=</span> <span class="n">qe</span><span class="o">.</span><span class="n">MarkovChain</span><span class="p">(</span><span class="n">p_temp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cclasses</span> <span class="o">=</span> <span class="n">markovchain</span><span class="o">.</span><span class="n">num_communication_classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_rclasses</span> <span class="o">=</span> <span class="n">markovchain</span><span class="o">.</span><span class="n">num_recurrent_classes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cclasses_indices</span> <span class="o">=</span> <span class="n">markovchain</span><span class="o">.</span><span class="n">communication_classes_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rclasses_indices</span> <span class="o">=</span> <span class="n">markovchain</span><span class="o">.</span><span class="n">recurrent_classes_indices</span>
        <span class="n">transient</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cclasses_indices</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rclasses_indices</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_tclasses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">transient</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">transient</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tclasses_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">transient</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tclasses_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">astates_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">p_temp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_astates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">astates_indices</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">markovchain</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Markov Chain is irreducible and is composed by:&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Markov Chain is reducible and is composed by:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rclasses</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1 Recurrent class (indices):&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> Recurrent classes (indices):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rclasses</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rclasses_indices</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tclasses</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;0 Transient classes.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tclasses</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1 Transient class (indices):&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> Transient classes (indices):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_tclasses</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tclasses_indices</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_astates</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Markov Chain has 0 absorbing states.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_astates</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Markov Chain has 1 absorbing state (index):&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;The Markov Chain has </span><span class="si">{0}</span><span class="s2"> absorbing states (indices):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">num_astates</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">astates_indices</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fmpt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_fmpt&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fmpt</span> <span class="o">=</span> <span class="n">fmpt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fmpt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">steady_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_steady_state&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_steady_state</span> <span class="o">=</span> <span class="n">steady_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_steady_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sojourn_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_st&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_st</span> <span class="o">=</span> <span class="n">sojourn_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_st</span></div>


<div class="viewcode-block" id="Spatial_Markov"><a class="viewcode-back" href="../../generated/giddy.markov.Spatial_Markov.html#giddy.markov.Spatial_Markov">[docs]</a><span class="k">class</span> <span class="nc">Spatial_Markov</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Markov transitions conditioned on the value of the spatial lag.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y               : array</span>
<span class="sd">                      (n, t), one row per observation, one column per state of</span>
<span class="sd">                      each observation, with as many columns as time periods.</span>
<span class="sd">    w               : W</span>
<span class="sd">                      spatial weights object.</span>
<span class="sd">    k               : integer, optional</span>
<span class="sd">                      number of classes (quantiles) for input time series y.</span>
<span class="sd">                      Default is 4. If discrete=True, k is determined</span>
<span class="sd">                      endogenously.</span>
<span class="sd">    m               : integer, optional</span>
<span class="sd">                      number of classes (quantiles) for the spatial lags of</span>
<span class="sd">                      regional time series. Default is 4. If discrete=True,</span>
<span class="sd">                      m is determined endogenously.</span>
<span class="sd">    permutations    : int, optional</span>
<span class="sd">                      number of permutations for use in randomization based</span>
<span class="sd">                      inference (the default is 0).</span>
<span class="sd">    fixed           : bool, optional</span>
<span class="sd">                      If true, discretization are taken over the entire n*t</span>
<span class="sd">                      pooled series and cutoffs can be user-defined. If</span>
<span class="sd">                      cutoffs and lag_cutoffs are not given, quantiles are</span>
<span class="sd">                      used. If false, quantiles are taken each time period</span>
<span class="sd">                      over n. Default is True.</span>
<span class="sd">    discrete        : bool, optional</span>
<span class="sd">                      If true, categorical spatial lags which are most common</span>
<span class="sd">                      categories of neighboring observations serve as the</span>
<span class="sd">                      conditioning and fixed is ignored; if false, weighted</span>
<span class="sd">                      averages of neighboring observations are used. Default is</span>
<span class="sd">                      false.</span>
<span class="sd">    cutoffs         : array, optional</span>
<span class="sd">                      users can specify the discretization cutoffs for</span>
<span class="sd">                      continuous time series. Default is None, meaning that</span>
<span class="sd">                      quantiles will be used for the discretization.</span>
<span class="sd">    lag_cutoffs     : array, optional</span>
<span class="sd">                      users can specify the discretization cutoffs for the</span>
<span class="sd">                      spatial lags of continuous time series. Default is</span>
<span class="sd">                      None, meaning that quantiles will be used for the</span>
<span class="sd">                      discretization.</span>
<span class="sd">    variable_name   : string</span>
<span class="sd">                      name of variable.</span>
<span class="sd">    fill_empty_classes: bool</span>
<span class="sd">                        If True, assign 1 to diagonal elements which fall in rows</span>
<span class="sd">                        full of 0s to ensure each conditional transition</span>
<span class="sd">                        probability matrix is a stochastic matrix (each row</span>
<span class="sd">                        sums up to 1). In other words, the probability of</span>
<span class="sd">                        staying at that state is 1.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    class_ids       : array</span>
<span class="sd">                      (n, t), discretized series if y is continuous. Otherwise</span>
<span class="sd">                      it is identical to y.</span>
<span class="sd">    classes         : array</span>
<span class="sd">                      (k, 1), all different classes (bins).</span>
<span class="sd">    lclass_ids      : array</span>
<span class="sd">                      (n, t), spatial lag series.</span>
<span class="sd">    lclasses        : array</span>
<span class="sd">                      (k, 1), all different classes (bins) for</span>
<span class="sd">                      spatial lags.</span>
<span class="sd">    p               : array</span>
<span class="sd">                      (k, k), transition probability matrix for a-spatial</span>
<span class="sd">                      Markov.</span>
<span class="sd">    s               : array</span>
<span class="sd">                      (k, ), steady state distribution for a-spatial Markov.</span>
<span class="sd">    f               : array</span>
<span class="sd">                      (k, k), first mean passage times for a-spatial Markov.</span>
<span class="sd">    transitions     : array</span>
<span class="sd">                      (k, k), counts of transitions between each state i and j</span>
<span class="sd">                      for a-spatial Markov.</span>
<span class="sd">    T               : array</span>
<span class="sd">                      (m, k, k), counts of transitions for each conditional</span>
<span class="sd">                      Markov.  T[0] is the matrix of transitions for</span>
<span class="sd">                      observations with lags in the 0th quantile; T[m-1] is the</span>
<span class="sd">                      transitions for the observations with lags in the m-1th.</span>
<span class="sd">    P               : array</span>
<span class="sd">                      (m, k, k), transition probability matrix for spatial</span>
<span class="sd">                      Markov first dimension is the conditioned on the lag.</span>
<span class="sd">    S               : arraylike</span>
<span class="sd">                      (m, k), steady state distributions for spatial Markov.</span>
<span class="sd">                      Each row is a conditional steady state distribution.</span>
<span class="sd">                      If one (or more) spatially conditional Markov chain is</span>
<span class="sd">                      reducible (having more than 1 steady state distribution),</span>
<span class="sd">                      this attribute is an array of m arrays of varying</span>
<span class="sd">                      dimensions.</span>
<span class="sd">    F               : array</span>
<span class="sd">                      (m, k, k),first mean passage times.</span>
<span class="sd">                      First dimension is conditioned on the spatial lag.</span>
<span class="sd">    shtest          : list</span>
<span class="sd">                      (k elements), each element of the list is a tuple for a</span>
<span class="sd">                      multinomial difference test between the steady state</span>
<span class="sd">                      distribution from a conditional distribution versus the</span>
<span class="sd">                      overall steady state distribution: first element of the</span>
<span class="sd">                      tuple is the chi2 value, second its p-value and the third</span>
<span class="sd">                      the degrees of freedom.</span>
<span class="sd">    chi2            : list</span>
<span class="sd">                      (k elements), each element of the list is a tuple for a</span>
<span class="sd">                      chi-squared test of the difference between the</span>
<span class="sd">                      conditional transition matrix against the overall</span>
<span class="sd">                      transition matrix: first element of the tuple is the chi2</span>
<span class="sd">                      value, second its p-value and the third the degrees of</span>
<span class="sd">                      freedom.</span>
<span class="sd">    x2              : float</span>
<span class="sd">                      sum of the chi2 values for each of the conditional tests.</span>
<span class="sd">                      Has an asymptotic chi2 distribution with k(k-1)(k-1)</span>
<span class="sd">                      degrees of freedom. Under the null that transition</span>
<span class="sd">                      probabilities are spatially homogeneous.</span>
<span class="sd">                      (see chi2 above)</span>
<span class="sd">    x2_dof          : int</span>
<span class="sd">                      degrees of freedom for homogeneity test.</span>
<span class="sd">    x2_pvalue       : float</span>
<span class="sd">                      pvalue for homogeneity test based on analytic.</span>
<span class="sd">                      distribution</span>
<span class="sd">    x2_rpvalue      : float</span>
<span class="sd">                      (if permutations&gt;0)</span>
<span class="sd">                      pseudo p-value for x2 based on random spatial</span>
<span class="sd">                      permutations of the rows of the original transitions.</span>
<span class="sd">    x2_realizations : array</span>
<span class="sd">                      (permutations,1), the values of x2 for the random</span>
<span class="sd">                      permutations.</span>
<span class="sd">    Q               : float</span>
<span class="sd">                      Chi-square test of homogeneity across lag classes based</span>
<span class="sd">                      on :cite:`Bickenbach2003`.</span>
<span class="sd">    Q_p_value       : float</span>
<span class="sd">                      p-value for Q.</span>
<span class="sd">    LR              : float</span>
<span class="sd">                      Likelihood ratio statistic for homogeneity across lag</span>
<span class="sd">                      classes based on :cite:`Bickenbach2003`.</span>
<span class="sd">    LR_p_value      : float</span>
<span class="sd">                      p-value for LR.</span>
<span class="sd">    dof_hom         : int</span>
<span class="sd">                      degrees of freedom for LR and Q, corrected for 0 cells.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on :cite:`Rey2001`.</span>

<span class="sd">    The shtest and chi2 tests should be used with caution as they are based on</span>
<span class="sd">    classic theory assuming random transitions. The x2 based test is</span>
<span class="sd">    preferable since it simulates the randomness under the null. It is an</span>
<span class="sd">    experimental test requiring further analysis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import libpysal</span>
<span class="sd">    &gt;&gt;&gt; from giddy.markov import Spatial_Markov</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; f = libpysal.io.open(libpysal.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">    &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in range(1929,2010)])</span>
<span class="sd">    &gt;&gt;&gt; pci = pci.transpose()</span>
<span class="sd">    &gt;&gt;&gt; rpci = pci/(pci.mean(axis=0))</span>
<span class="sd">    &gt;&gt;&gt; w = libpysal.io.open(libpysal.examples.get_path(&quot;states48.gal&quot;)).read()</span>
<span class="sd">    &gt;&gt;&gt; w.transform = &#39;r&#39;</span>

<span class="sd">    Now we create a `Spatial_Markov` instance for the continuous relative per</span>
<span class="sd">    capita income time series for 48 US lower states 1929-2009. The current</span>
<span class="sd">    implementation allows users to classify the continuous incomes in a more</span>
<span class="sd">    flexible way.</span>

<span class="sd">    (1) Global quintiles to discretize the income data (k=5), and global</span>
<span class="sd">    quintiles to discretize the spatial lags of incomes (m=5).</span>

<span class="sd">    &gt;&gt;&gt; sm = Spatial_Markov(rpci, w, fixed=True, k=5, m=5, variable_name=&#39;rpci&#39;)</span>

<span class="sd">    We can examine the cutoffs for the incomes and cutoffs for the spatial lags</span>

<span class="sd">    &gt;&gt;&gt; sm.cutoffs</span>
<span class="sd">    array([0.83999133, 0.94707545, 1.03242697, 1.14911154])</span>
<span class="sd">    &gt;&gt;&gt; sm.lag_cutoffs</span>
<span class="sd">    array([0.88973386, 0.95891917, 1.01469758, 1.1183566 ])</span>

<span class="sd">    Obviously, they are slightly different.</span>

<span class="sd">    We now look at the estimated spatially lag conditioned transition</span>
<span class="sd">    probability matrices.</span>

<span class="sd">    &gt;&gt;&gt; for p in sm.P:</span>
<span class="sd">    ...     print(p)</span>
<span class="sd">    [[0.96341463 0.0304878  0.00609756 0.         0.        ]</span>
<span class="sd">     [0.06040268 0.83221477 0.10738255 0.         0.        ]</span>
<span class="sd">     [0.         0.14       0.74       0.12       0.        ]</span>
<span class="sd">     [0.         0.03571429 0.32142857 0.57142857 0.07142857]</span>
<span class="sd">     [0.         0.         0.         0.16666667 0.83333333]]</span>
<span class="sd">    [[0.79831933 0.16806723 0.03361345 0.         0.        ]</span>
<span class="sd">     [0.0754717  0.88207547 0.04245283 0.         0.        ]</span>
<span class="sd">     [0.00537634 0.06989247 0.8655914  0.05913978 0.        ]</span>
<span class="sd">     [0.         0.         0.06372549 0.90196078 0.03431373]</span>
<span class="sd">     [0.         0.         0.         0.19444444 0.80555556]]</span>
<span class="sd">    [[0.84693878 0.15306122 0.         0.         0.        ]</span>
<span class="sd">     [0.08133971 0.78947368 0.1291866  0.         0.        ]</span>
<span class="sd">     [0.00518135 0.0984456  0.79274611 0.0984456  0.00518135]</span>
<span class="sd">     [0.         0.         0.09411765 0.87058824 0.03529412]</span>
<span class="sd">     [0.         0.         0.         0.10204082 0.89795918]]</span>
<span class="sd">    [[0.8852459  0.09836066 0.         0.01639344 0.        ]</span>
<span class="sd">     [0.03875969 0.81395349 0.13953488 0.         0.00775194]</span>
<span class="sd">     [0.0049505  0.09405941 0.77722772 0.11881188 0.0049505 ]</span>
<span class="sd">     [0.         0.02339181 0.12865497 0.75438596 0.09356725]</span>
<span class="sd">     [0.         0.         0.         0.09661836 0.90338164]]</span>
<span class="sd">    [[0.33333333 0.66666667 0.         0.         0.        ]</span>
<span class="sd">     [0.0483871  0.77419355 0.16129032 0.01612903 0.        ]</span>
<span class="sd">     [0.01149425 0.16091954 0.74712644 0.08045977 0.        ]</span>
<span class="sd">     [0.         0.01036269 0.06217617 0.89637306 0.03108808]</span>
<span class="sd">     [0.         0.         0.         0.02352941 0.97647059]]</span>


<span class="sd">    The probability of a poor state remaining poor is 0.963 if their</span>
<span class="sd">    neighbors are in the 1st quintile and 0.798 if their neighbors are</span>
<span class="sd">    in the 2nd quintile. The probability of a rich economy remaining</span>
<span class="sd">    rich is 0.976 if their neighbors are in the 5th quintile, but if their</span>
<span class="sd">    neighbors are in the 4th quintile this drops to 0.903.</span>

<span class="sd">    The global transition probability matrix is estimated:</span>

<span class="sd">    &gt;&gt;&gt; print(sm.p)</span>
<span class="sd">    [[0.91461837 0.07503234 0.00905563 0.00129366 0.        ]</span>
<span class="sd">     [0.06570302 0.82654402 0.10512484 0.00131406 0.00131406]</span>
<span class="sd">     [0.00520833 0.10286458 0.79427083 0.09505208 0.00260417]</span>
<span class="sd">     [0.         0.00913838 0.09399478 0.84856397 0.04830287]</span>
<span class="sd">     [0.         0.         0.         0.06217617 0.93782383]]</span>

<span class="sd">    The Q and likelihood ratio statistics are both significant indicating</span>
<span class="sd">    the dynamics are not homogeneous across the lag classes:</span>

<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.LR</span>
<span class="sd">    &#39;170.659&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.Q</span>
<span class="sd">    &#39;200.624&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.LR_p_value</span>
<span class="sd">    &#39;0.000&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.Q_p_value</span>
<span class="sd">    &#39;0.000&#39;</span>
<span class="sd">    &gt;&gt;&gt; sm.dof_hom</span>
<span class="sd">    60</span>

<span class="sd">    The long run distribution for states with poor (rich) neighbors has</span>
<span class="sd">    0.435 (0.018) of the values in the first quintile, 0.263 (0.200) in</span>
<span class="sd">    the second quintile, 0.204 (0.190) in the third, 0.0684 (0.255) in the</span>
<span class="sd">    fourth and 0.029 (0.337) in the fifth quintile.</span>

<span class="sd">    &gt;&gt;&gt; sm.S</span>
<span class="sd">    array([[0.43509425, 0.2635327 , 0.20363044, 0.06841983, 0.02932278],</span>
<span class="sd">           [0.13391287, 0.33993305, 0.25153036, 0.23343016, 0.04119356],</span>
<span class="sd">           [0.12124869, 0.21137444, 0.2635101 , 0.29013417, 0.1137326 ],</span>
<span class="sd">           [0.0776413 , 0.19748806, 0.25352636, 0.22480415, 0.24654013],</span>
<span class="sd">           [0.01776781, 0.19964349, 0.19009833, 0.25524697, 0.3372434 ]])</span>

<span class="sd">    States with incomes in the first quintile with neighbors in the</span>
<span class="sd">    first quintile return to the first quartile after 2.298 years, after</span>
<span class="sd">    leaving the first quintile. They enter the fourth quintile after</span>
<span class="sd">    80.810 years after leaving the first quintile, on average.</span>
<span class="sd">    Poor states within neighbors in the fourth quintile return to the</span>
<span class="sd">    first quintile, on average, after 12.88 years, and would enter the</span>
<span class="sd">    fourth quintile after 28.473 years.</span>

<span class="sd">    &gt;&gt;&gt; for f in sm.F:</span>
<span class="sd">    ...     print(f)</span>
<span class="sd">    [[  2.29835259  28.95614035  46.14285714  80.80952381 279.42857143]</span>
<span class="sd">     [ 33.86549708   3.79459555  22.57142857  57.23809524 255.85714286]</span>
<span class="sd">     [ 43.60233918   9.73684211   4.91085714  34.66666667 233.28571429]</span>
<span class="sd">     [ 46.62865497  12.76315789   6.25714286  14.61564626 198.61904762]</span>
<span class="sd">     [ 52.62865497  18.76315789  12.25714286   6.          34.1031746 ]]</span>
<span class="sd">    [[  7.46754205   9.70574606  25.76785714  74.53116883 194.23446197]</span>
<span class="sd">     [ 27.76691978   2.94175577  24.97142857  73.73474026 193.4380334 ]</span>
<span class="sd">     [ 53.57477715  28.48447637   3.97566318  48.76331169 168.46660482]</span>
<span class="sd">     [ 72.03631562  46.94601483  18.46153846   4.28393653 119.70329314]</span>
<span class="sd">     [ 77.17917276  52.08887197  23.6043956    5.14285714  24.27564033]]</span>
<span class="sd">    [[  8.24751154   6.53333333  18.38765432  40.70864198 112.76732026]</span>
<span class="sd">     [ 47.35040872   4.73094099  11.85432099  34.17530864 106.23398693]</span>
<span class="sd">     [ 69.42288828  24.76666667   3.794921    22.32098765  94.37966594]</span>
<span class="sd">     [ 83.72288828  39.06666667  14.3          3.44668119  76.36702977]</span>
<span class="sd">     [ 93.52288828  48.86666667  24.1          9.8          8.79255406]]</span>
<span class="sd">    [[ 12.87974382  13.34847151  19.83446328  28.47257282  55.82395142]</span>
<span class="sd">     [ 99.46114206   5.06359731  10.54545198  23.05133495  49.68944423]</span>
<span class="sd">     [117.76777159  23.03735526   3.94436301  15.0843986   43.57927247]</span>
<span class="sd">     [127.89752089  32.4393006   14.56853107   4.44831643  31.63099455]</span>
<span class="sd">     [138.24752089  42.7893006   24.91853107  10.35         4.05613474]]</span>
<span class="sd">    [[ 56.2815534    1.5         10.57236842  27.02173913 110.54347826]</span>
<span class="sd">     [ 82.9223301    5.00892857   9.07236842  25.52173913 109.04347826]</span>
<span class="sd">     [ 97.17718447  19.53125      5.26043557  21.42391304 104.94565217]</span>
<span class="sd">     [127.1407767   48.74107143  33.29605263   3.91777427  83.52173913]</span>
<span class="sd">     [169.6407767   91.24107143  75.79605263  42.5          2.96521739]]</span>

<span class="sd">    (2) Global quintiles to discretize the income data (k=5), and global</span>
<span class="sd">    quartiles to discretize the spatial lags of incomes (m=4).</span>

<span class="sd">    &gt;&gt;&gt; sm = Spatial_Markov(rpci, w, fixed=True, k=5, m=4, variable_name=&#39;rpci&#39;)</span>

<span class="sd">    We can also examine the cutoffs for the incomes and cutoffs for the spatial</span>
<span class="sd">    lags:</span>

<span class="sd">    &gt;&gt;&gt; sm.cutoffs</span>
<span class="sd">    array([0.83999133, 0.94707545, 1.03242697, 1.14911154])</span>
<span class="sd">    &gt;&gt;&gt; sm.lag_cutoffs</span>
<span class="sd">    array([0.91440247, 0.98583079, 1.08698351])</span>

<span class="sd">    We now look at the estimated spatially lag conditioned transition</span>
<span class="sd">    probability matrices.</span>

<span class="sd">    &gt;&gt;&gt; for p in sm.P:</span>
<span class="sd">    ...     print(p)</span>
<span class="sd">    [[0.95708955 0.03544776 0.00746269 0.         0.        ]</span>
<span class="sd">     [0.05825243 0.83980583 0.10194175 0.         0.        ]</span>
<span class="sd">     [0.         0.1294964  0.76258993 0.10791367 0.        ]</span>
<span class="sd">     [0.         0.01538462 0.18461538 0.72307692 0.07692308]</span>
<span class="sd">     [0.         0.         0.         0.14285714 0.85714286]]</span>
<span class="sd">    [[0.7421875  0.234375   0.0234375  0.         0.        ]</span>
<span class="sd">     [0.08550186 0.85130112 0.06319703 0.         0.        ]</span>
<span class="sd">     [0.00865801 0.06926407 0.86147186 0.05627706 0.004329  ]</span>
<span class="sd">     [0.         0.         0.05363985 0.92337165 0.02298851]</span>
<span class="sd">     [0.         0.         0.         0.13432836 0.86567164]]</span>
<span class="sd">    [[0.95145631 0.04854369 0.         0.         0.        ]</span>
<span class="sd">     [0.06       0.79       0.145      0.         0.005     ]</span>
<span class="sd">     [0.00358423 0.10394265 0.7921147  0.09677419 0.00358423]</span>
<span class="sd">     [0.         0.01630435 0.13586957 0.75543478 0.0923913 ]</span>
<span class="sd">     [0.         0.         0.         0.10204082 0.89795918]]</span>
<span class="sd">    [[0.16666667 0.66666667 0.         0.16666667 0.        ]</span>
<span class="sd">     [0.03488372 0.80232558 0.15116279 0.01162791 0.        ]</span>
<span class="sd">     [0.00840336 0.13445378 0.70588235 0.1512605  0.        ]</span>
<span class="sd">     [0.         0.01171875 0.08203125 0.87109375 0.03515625]</span>
<span class="sd">     [0.         0.         0.         0.03434343 0.96565657]]</span>

<span class="sd">    We now obtain 4 5*5 spatial lag conditioned transition probability</span>
<span class="sd">    matrices instead of 5 as in case (1).</span>

<span class="sd">    The Q and likelihood ratio statistics are still both significant.</span>

<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.LR</span>
<span class="sd">    &#39;172.105&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.Q</span>
<span class="sd">    &#39;321.128&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.LR_p_value</span>
<span class="sd">    &#39;0.000&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%sm.Q_p_value</span>
<span class="sd">    &#39;0.000&#39;</span>
<span class="sd">    &gt;&gt;&gt; sm.dof_hom</span>
<span class="sd">    45</span>

<span class="sd">    (3) We can also set the cutoffs for relative incomes and their</span>
<span class="sd">    spatial lags manually.</span>
<span class="sd">    For example, we want the defining cutoffs to be [0.8, 0.9, 1, 1.2],</span>
<span class="sd">    meaning that relative incomes:</span>
<span class="sd">    2.1 smaller than 0.8 : class 0</span>
<span class="sd">    2.2 between 0.8 and 0.9: class 1</span>
<span class="sd">    2.3 between 0.9 and 1.0 : class 2</span>
<span class="sd">    2.4 between 1.0 and 1.2: class 3</span>
<span class="sd">    2.5 larger than 1.2: class 4</span>

<span class="sd">    &gt;&gt;&gt; cc = np.array([0.8, 0.9, 1, 1.2])</span>
<span class="sd">    &gt;&gt;&gt; sm = Spatial_Markov(rpci, w, cutoffs=cc, lag_cutoffs=cc, variable_name=&#39;rpci&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sm.cutoffs</span>
<span class="sd">    array([0.8, 0.9, 1. , 1.2])</span>
<span class="sd">    &gt;&gt;&gt; sm.k</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; sm.lag_cutoffs</span>
<span class="sd">    array([0.8, 0.9, 1. , 1.2])</span>
<span class="sd">    &gt;&gt;&gt; sm.m</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; for p in sm.P:</span>
<span class="sd">    ...     print(p)</span>
<span class="sd">    [[0.96703297 0.03296703 0.         0.         0.        ]</span>
<span class="sd">     [0.10638298 0.68085106 0.21276596 0.         0.        ]</span>
<span class="sd">     [0.         0.14285714 0.7755102  0.08163265 0.        ]</span>
<span class="sd">     [0.         0.         0.5        0.5        0.        ]</span>
<span class="sd">     [0.         0.         0.         0.         0.        ]]</span>
<span class="sd">    [[0.88636364 0.10606061 0.00757576 0.         0.        ]</span>
<span class="sd">     [0.04402516 0.89308176 0.06289308 0.         0.        ]</span>
<span class="sd">     [0.         0.05882353 0.8627451  0.07843137 0.        ]</span>
<span class="sd">     [0.         0.         0.13846154 0.86153846 0.        ]</span>
<span class="sd">     [0.         0.         0.         0.         1.        ]]</span>
<span class="sd">    [[0.78082192 0.17808219 0.02739726 0.01369863 0.        ]</span>
<span class="sd">     [0.03488372 0.90406977 0.05813953 0.00290698 0.        ]</span>
<span class="sd">     [0.         0.05919003 0.84735202 0.09034268 0.00311526]</span>
<span class="sd">     [0.         0.         0.05811623 0.92985972 0.01202405]</span>
<span class="sd">     [0.         0.         0.         0.14285714 0.85714286]]</span>
<span class="sd">    [[0.82692308 0.15384615 0.         0.01923077 0.        ]</span>
<span class="sd">     [0.0703125  0.7890625  0.125      0.015625   0.        ]</span>
<span class="sd">     [0.00295858 0.06213018 0.82248521 0.10946746 0.00295858]</span>
<span class="sd">     [0.         0.00185529 0.07606679 0.88497217 0.03710575]</span>
<span class="sd">     [0.         0.         0.         0.07803468 0.92196532]]</span>
<span class="sd">    [[0.         0.         0.         0.         0.        ]</span>
<span class="sd">     [0.         0.         0.         0.         0.        ]</span>
<span class="sd">     [0.         0.06666667 0.9        0.03333333 0.        ]</span>
<span class="sd">     [0.         0.         0.05660377 0.90566038 0.03773585]</span>
<span class="sd">     [0.         0.         0.         0.03932584 0.96067416]]</span>

<span class="sd">    (3.1) As we can see from the above estimated conditional transition</span>
<span class="sd">    probability matrix, some rows are full of zeros which violate the</span>
<span class="sd">    requirement of a transition probability matrix that every row sums to 1.</span>
<span class="sd">    We can easily adjust this assigning fill_empty_classes = True when initializing</span>
<span class="sd">    Spatial_Markov.</span>

<span class="sd">    &gt;&gt;&gt; sm = Spatial_Markov(rpci, w, cutoffs=cc, lag_cutoffs=cc, fill_empty_classes=True)</span>
<span class="sd">    &gt;&gt;&gt; for p in sm.P:</span>
<span class="sd">    ...     print(p)</span>
<span class="sd">    [[0.96703297 0.03296703 0.         0.         0.        ]</span>
<span class="sd">     [0.10638298 0.68085106 0.21276596 0.         0.        ]</span>
<span class="sd">     [0.         0.14285714 0.7755102  0.08163265 0.        ]</span>
<span class="sd">     [0.         0.         0.5        0.5        0.        ]</span>
<span class="sd">     [0.         0.         0.         0.         1.        ]]</span>
<span class="sd">    [[0.88636364 0.10606061 0.00757576 0.         0.        ]</span>
<span class="sd">     [0.04402516 0.89308176 0.06289308 0.         0.        ]</span>
<span class="sd">     [0.         0.05882353 0.8627451  0.07843137 0.        ]</span>
<span class="sd">     [0.         0.         0.13846154 0.86153846 0.        ]</span>
<span class="sd">     [0.         0.         0.         0.         1.        ]]</span>
<span class="sd">    [[0.78082192 0.17808219 0.02739726 0.01369863 0.        ]</span>
<span class="sd">     [0.03488372 0.90406977 0.05813953 0.00290698 0.        ]</span>
<span class="sd">     [0.         0.05919003 0.84735202 0.09034268 0.00311526]</span>
<span class="sd">     [0.         0.         0.05811623 0.92985972 0.01202405]</span>
<span class="sd">     [0.         0.         0.         0.14285714 0.85714286]]</span>
<span class="sd">    [[0.82692308 0.15384615 0.         0.01923077 0.        ]</span>
<span class="sd">     [0.0703125  0.7890625  0.125      0.015625   0.        ]</span>
<span class="sd">     [0.00295858 0.06213018 0.82248521 0.10946746 0.00295858]</span>
<span class="sd">     [0.         0.00185529 0.07606679 0.88497217 0.03710575]</span>
<span class="sd">     [0.         0.         0.         0.07803468 0.92196532]]</span>
<span class="sd">    [[1.         0.         0.         0.         0.        ]</span>
<span class="sd">     [0.         1.         0.         0.         0.        ]</span>
<span class="sd">     [0.         0.06666667 0.9        0.03333333 0.        ]</span>
<span class="sd">     [0.         0.         0.05660377 0.90566038 0.03773585]</span>
<span class="sd">     [0.         0.         0.         0.03932584 0.96067416]]</span>
<span class="sd">    &gt;&gt;&gt; sm.S[0]</span>
<span class="sd">    array([[0.54148249, 0.16780007, 0.24991499, 0.04080245, 0.        ],</span>
<span class="sd">           [0.        , 0.        , 0.        , 0.        , 1.        ]])</span>
<span class="sd">    &gt;&gt;&gt; sm.S[2]</span>
<span class="sd">    array([0.03607655, 0.22667277, 0.25883041, 0.43607249, 0.04234777])</span>

<span class="sd">    (4) Spatial_Markov also accept discrete time series and calculate</span>
<span class="sd">    categorical spatial lags on which several transition probability matrices</span>
<span class="sd">    are conditioned.</span>
<span class="sd">    Let&#39;s still use the US state income time series to demonstrate. We first</span>
<span class="sd">    discretize them into categories and then pass them to Spatial_Markov.</span>

<span class="sd">    &gt;&gt;&gt; import mapclassify as mc</span>
<span class="sd">    &gt;&gt;&gt; y = mc.Quantiles(rpci.flatten(), k=5).yb.reshape(rpci.shape)</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(5)</span>
<span class="sd">    &gt;&gt;&gt; sm = Spatial_Markov(y, w, discrete=True, variable_name=&#39;discretized rpci&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sm.k</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; sm.m</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; for p in sm.P:</span>
<span class="sd">    ...     print(p)</span>
<span class="sd">    [[0.94787645 0.04440154 0.00772201 0.         0.        ]</span>
<span class="sd">     [0.08333333 0.81060606 0.10606061 0.         0.        ]</span>
<span class="sd">     [0.         0.12765957 0.79787234 0.07446809 0.        ]</span>
<span class="sd">     [0.         0.02777778 0.22222222 0.66666667 0.08333333]</span>
<span class="sd">     [0.         0.         0.         0.33333333 0.66666667]]</span>
<span class="sd">    [[0.888      0.096      0.016      0.         0.        ]</span>
<span class="sd">     [0.06049822 0.84341637 0.09608541 0.         0.        ]</span>
<span class="sd">     [0.00666667 0.10666667 0.81333333 0.07333333 0.        ]</span>
<span class="sd">     [0.         0.         0.08527132 0.86821705 0.04651163]</span>
<span class="sd">     [0.         0.         0.         0.10204082 0.89795918]]</span>
<span class="sd">    [[0.65217391 0.32608696 0.02173913 0.         0.        ]</span>
<span class="sd">     [0.07446809 0.80851064 0.11170213 0.         0.00531915]</span>
<span class="sd">     [0.01071429 0.1        0.76428571 0.11785714 0.00714286]</span>
<span class="sd">     [0.         0.00552486 0.09392265 0.86187845 0.03867403]</span>
<span class="sd">     [0.         0.         0.         0.13157895 0.86842105]]</span>
<span class="sd">    [[0.91935484 0.06451613 0.         0.01612903 0.        ]</span>
<span class="sd">     [0.06796117 0.90291262 0.02912621 0.         0.        ]</span>
<span class="sd">     [0.         0.05755396 0.87769784 0.0647482  0.        ]</span>
<span class="sd">     [0.         0.02150538 0.10752688 0.80107527 0.06989247]</span>
<span class="sd">     [0.         0.         0.         0.08064516 0.91935484]]</span>
<span class="sd">    [[0.81818182 0.18181818 0.         0.         0.        ]</span>
<span class="sd">     [0.01754386 0.70175439 0.26315789 0.01754386 0.        ]</span>
<span class="sd">     [0.         0.14285714 0.73333333 0.12380952 0.        ]</span>
<span class="sd">     [0.         0.0042735  0.06837607 0.89316239 0.03418803]</span>
<span class="sd">     [0.         0.         0.         0.03891051 0.96108949]]</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spatial_Markov.__init__"><a class="viewcode-back" href="../../generated/giddy.markov.Spatial_Markov.html#giddy.markov.Spatial_Markov.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">w</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">permutations</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cutoffs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lag_cutoffs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_empty_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="o">=</span> <span class="n">discrete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoffs</span> <span class="o">=</span> <span class="n">cutoffs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag_cutoffs</span> <span class="o">=</span> <span class="n">lag_cutoffs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name</span> <span class="o">=</span> <span class="n">variable_name</span>

        <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">label_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)))</span>
            <span class="n">y_int</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">y_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">label_dict</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">yi</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lclass_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_ids</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_classify</span><span class="p">(</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">cutoffs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoffs</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>

        <span class="n">classic</span> <span class="o">=</span> <span class="n">Markov</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_ids</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="n">fill_empty_classes</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">classic</span><span class="o">.</span><span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="n">classic</span><span class="o">.</span><span class="n">transitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="n">fill_empty_classes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">permutations</span><span class="p">:</span>
            <span class="n">nrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">x2_realizations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">permutations</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
                <span class="n">T</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc</span><span class="p">(</span><span class="n">nrp</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="n">chi2</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)]</span>
                <span class="n">x2s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
                <span class="n">x2_realizations</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2s</span>
                <span class="k">if</span> <span class="n">x2s</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x2</span><span class="p">:</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2_rpvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">counter</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2_realizations</span> <span class="o">=</span> <span class="n">x2_realizations</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_s&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">steady_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_S&quot;</span><span class="p">):</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">):</span>
                <span class="n">_S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">steady_state</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="c1"># if np.array(_S).dtype is np.dtype(&#39;O&#39;):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_S</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_f&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">fmpt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_F&quot;</span><span class="p">):</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">):</span>
                <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmpt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_F</span>

    <span class="c1"># bickenbach and bode tests</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ht</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ht&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ht</span> <span class="o">=</span> <span class="n">homogeneity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ht</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_Q&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ht</span><span class="o">.</span><span class="n">Q</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Q_p_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Q_p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ht</span><span class="o">.</span><span class="n">Q_p_value</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_p_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">LR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ht</span><span class="o">.</span><span class="n">LR</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">LR_p_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LR_p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ht</span><span class="o">.</span><span class="n">LR_p_value</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LR_p_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dof_hom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dof_hom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ht</span><span class="o">.</span><span class="n">dof</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_hom</span>

    <span class="c1"># shtests</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shtest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_shtest&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shtest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mn_test</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shtest</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_chi2&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chi2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chi2_test</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chi2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_x2&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chi2</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x2_pvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_x2_pvalue&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x2_pvalue</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x2_dof</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2_pvalue</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x2_dof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_x2_dof&quot;</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x2_dof</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2_dof</span>

    <span class="k">def</span> <span class="nf">_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper to estimate spatial lag conditioned Markov transition</span>
<span class="sd">        probability matrices based on maximum likelihood techniques.</span>

<span class="sd">        If fill_empty_classes=True, assign 1 to diagonal elements which fall in rows</span>
<span class="sd">        full of 0s to ensure each conditional transition probability matrix</span>
<span class="sd">        is a stochastic matrix (each row sums up to 1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lclass_ids</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">lag_categorical</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_ids</span><span class="p">,</span> <span class="n">ties</span><span class="o">=</span><span class="s2">&quot;tryself&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ly</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">lag_spatial</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lclass_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_cutoffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_classify</span><span class="p">(</span>
                <span class="n">ly</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_cutoffs</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lclasses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">T</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lclass_ids</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">t1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_ids</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">t1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_ids</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">t2</span><span class="p">]</span>
                <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
            <span class="n">row_sum</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">row_sum</span> <span class="o">=</span> <span class="n">row_sum</span> <span class="o">+</span> <span class="p">(</span><span class="n">row_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">row_sum</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_i</span>

        <span class="k">if</span> <span class="n">fill_empty_classes</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">fill_empty_diagonals</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">P</span>

    <span class="k">def</span> <span class="nf">_mn_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        helper to calculate tests of differences between steady state</span>
<span class="sd">        distributions from the conditional and overall distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">rn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">))</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ssmnp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rn</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mat</span>

    <span class="k">def</span> <span class="nf">_ssmnp_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Steady state multinomial probability difference test.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        p1       :  array</span>
<span class="sd">                    (k, ), first steady state probability distribution.</span>
<span class="sd">        p1       :  array</span>
<span class="sd">                    (k, ), second steady state probability distribution.</span>
<span class="sd">        nt       :  int</span>
<span class="sd">                    number of transitions to base the test on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">                   (3 elements)</span>
<span class="sd">                   (chi2 value, pvalue, degrees of freedom)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">o</span> <span class="o">=</span> <span class="n">nt</span> <span class="o">*</span> <span class="n">p2</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">nt</span> <span class="o">*</span> <span class="n">p1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">o</span> <span class="o">-</span> <span class="n">e</span><span class="p">),</span> <span class="p">(</span><span class="n">o</span> <span class="o">-</span> <span class="n">e</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">e</span>
        <span class="n">chi2</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_chi2_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        helper to calculate tests of differences between the conditional</span>
<span class="sd">        transition matrices and the overall transitions matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">rn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">))</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">chi2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rn</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mat</span>

<div class="viewcode-block" id="Spatial_Markov.summary"><a class="viewcode-back" href="../../generated/giddy.markov.Spatial_Markov.html#giddy.markov.Spatial_Markov.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A summary method to call the Markov homogeneity test to test for</span>
<span class="sd">        temporally lagged spatial dependence.</span>

<span class="sd">        To learn more about the properties of the tests, refer to</span>
<span class="sd">        :cite:`Rey2016a` and :cite:`Kang2018`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">class_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;C</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)]</span>
        <span class="n">regime_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;LAG</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)]</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">homogeneity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">class_names</span><span class="o">=</span><span class="n">class_names</span><span class="p">,</span> <span class="n">regime_names</span><span class="o">=</span><span class="n">regime_names</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Spatial Markov Test&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">title</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name</span>
        <span class="k">if</span> <span class="n">file_name</span><span class="p">:</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_maybe_classify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">cutoffs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method for classifying continuous data.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">cutoffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">:</span>
                <span class="n">mcyb</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">Quantiles</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                <span class="n">yb</span> <span class="o">=</span> <span class="n">mcyb</span><span class="o">.</span><span class="n">yb</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">cutoffs</span> <span class="o">=</span> <span class="n">mcyb</span><span class="o">.</span><span class="n">bins</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutoffs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">yb</span><span class="p">,</span> <span class="n">cutoffs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">mc</span><span class="o">.</span><span class="n">Quantiles</span><span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">yb</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cols</span><span class="p">)]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">yb</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">k</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cutoffs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cutoffs</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
            <span class="n">cutoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cutoffs</span><span class="p">)</span>
            <span class="n">yb</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">UserDefined</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cutoffs</span><span class="p">))</span><span class="o">.</span><span class="n">yb</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutoffs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">yb</span><span class="p">,</span> <span class="n">cutoffs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span></div>


<span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    chi-squared test of difference between two transition matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    T1    : array</span>
<span class="sd">            (k, k), matrix of transitions (counts).</span>
<span class="sd">    T2    : array</span>
<span class="sd">            (k, k), matrix of transitions (counts) to use to form the</span>
<span class="sd">            probabilities under the null.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">          : tuple</span>
<span class="sd">            (3 elements).</span>
<span class="sd">            (chi2 value, pvalue, degrees of freedom).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import libpysal</span>
<span class="sd">    &gt;&gt;&gt; from giddy.markov import Spatial_Markov, chi2</span>
<span class="sd">    &gt;&gt;&gt; f = libpysal.io.open(libpysal.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">    &gt;&gt;&gt; years = list(range(1929, 2010))</span>
<span class="sd">    &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in years]).transpose()</span>
<span class="sd">    &gt;&gt;&gt; rpci = pci/(pci.mean(axis=0))</span>
<span class="sd">    &gt;&gt;&gt; w = libpysal.io.open(libpysal.examples.get_path(&quot;states48.gal&quot;)).read()</span>
<span class="sd">    &gt;&gt;&gt; w.transform=&#39;r&#39;</span>
<span class="sd">    &gt;&gt;&gt; sm = Spatial_Markov(rpci, w, fixed=True)</span>
<span class="sd">    &gt;&gt;&gt; T1 = sm.T[0]</span>
<span class="sd">    &gt;&gt;&gt; T1</span>
<span class="sd">    array([[562.,  22.,   1.,   0.],</span>
<span class="sd">           [ 12., 201.,  22.,   0.],</span>
<span class="sd">           [  0.,  17.,  97.,   4.],</span>
<span class="sd">           [  0.,   0.,   3.,  19.]])</span>
<span class="sd">    &gt;&gt;&gt; T2 = sm.transitions</span>
<span class="sd">    &gt;&gt;&gt; T2</span>
<span class="sd">    array([[884.,  77.,   4.,   0.],</span>
<span class="sd">           [ 68., 794.,  87.,   3.],</span>
<span class="sd">           [  1.,  92., 815.,  51.],</span>
<span class="sd">           [  1.,   0.,  60., 903.]])</span>
<span class="sd">    &gt;&gt;&gt; chi2(T1,T2)</span>
<span class="sd">    (23.39728441473295, 0.005363116704861337, 9)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Second matrix is used to form the probabilities under the null.</span>
<span class="sd">    Marginal sums from first matrix are distributed across these probabilities</span>
<span class="sd">    under the null. In other words the observed transitions are taken from T1</span>
<span class="sd">    while the expected transitions are formed as follows</span>

<span class="sd">    .. math::</span>

<span class="sd">            E_{i,j} = \sum_j T1_{i,j} * T2_{i,j}/\sum_j T2_{i,j}</span>

<span class="sd">    Degrees of freedom corrected for any rows in either T1 or T2 that have</span>
<span class="sd">    zero total transitions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rs2</span> <span class="o">=</span> <span class="n">T2</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rs1</span> <span class="o">=</span> <span class="n">T1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rs2nz</span> <span class="o">=</span> <span class="n">rs2</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">rs1nz</span> <span class="o">=</span> <span class="n">rs1</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">dof1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rs1nz</span><span class="p">)</span>
    <span class="n">dof2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rs2nz</span><span class="p">)</span>
    <span class="n">rs2</span> <span class="o">=</span> <span class="n">rs2</span> <span class="o">+</span> <span class="p">(</span><span class="n">rs2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dof</span> <span class="o">=</span> <span class="p">(</span><span class="n">dof1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dof2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">rs2</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T2</span><span class="p">))</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">rs1</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">T1</span> <span class="o">-</span> <span class="n">E</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="p">(</span><span class="n">E</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">chi2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">E</span>
    <span class="n">chi2</span> <span class="o">=</span> <span class="n">chi2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">dof</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chi2</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">dof</span>


<div class="viewcode-block" id="LISA_Markov"><a class="viewcode-back" href="../../generated/giddy.markov.LISA_Markov.html#giddy.markov.LISA_Markov">[docs]</a><span class="k">class</span> <span class="nc">LISA_Markov</span><span class="p">(</span><span class="n">Markov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Markov for Local Indicators of Spatial Association</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y                  : array</span>
<span class="sd">                         (n, t), n cross-sectional units observed over t time</span>
<span class="sd">                         periods.</span>
<span class="sd">    w                  : W</span>
<span class="sd">                         spatial weights object.</span>
<span class="sd">    permutations       : int, optional</span>
<span class="sd">                         number of permutations used to determine LISA</span>
<span class="sd">                         significance (the default is 0).</span>
<span class="sd">    significance_level : float, optional</span>
<span class="sd">                         significance level (two-sided) for filtering</span>
<span class="sd">                         significant LISA endpoints in a transition (the</span>
<span class="sd">                         default is 0.05).</span>
<span class="sd">    geoda_quads        : bool</span>
<span class="sd">                         If True use GeoDa scheme: HH=1, LL=2, LH=3, HL=4.</span>
<span class="sd">                         If False use PySAL Scheme: HH=1, LH=2, LL=3, HL=4.</span>
<span class="sd">                         (the default is False).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    chi_2        : tuple</span>
<span class="sd">                   (3 elements)</span>
<span class="sd">                   (chi square test statistic, p-value, degrees of freedom) for</span>
<span class="sd">                   test that dynamics of y are independent of dynamics of wy.</span>
<span class="sd">    classes      : array</span>
<span class="sd">                   (4, 1)</span>
<span class="sd">                   1=HH, 2=LH, 3=LL, 4=HL (own, lag)</span>
<span class="sd">                   1=HH, 2=LL, 3=LH, 4=HL (own, lag) (if geoda_quads=True)</span>
<span class="sd">    expected_t   : array</span>
<span class="sd">                   (4, 4), expected number of transitions under the null that</span>
<span class="sd">                   dynamics of y are independent of dynamics of wy.</span>
<span class="sd">    move_types   : matrix</span>
<span class="sd">                   (n, t-1), integer values indicating which type of LISA</span>
<span class="sd">                   transition occurred (q1 is quadrant in period 1, q2 is</span>
<span class="sd">                   quadrant in period 2).</span>

<span class="sd">                   .. table:: Move Types</span>
<span class="sd">                      :widths: auto</span>

<span class="sd">                      ==  ==     =========</span>
<span class="sd">                      q1  q2     move_type</span>
<span class="sd">                      ==  ==     =========</span>
<span class="sd">                      1   1      1</span>
<span class="sd">                      1   2      2</span>
<span class="sd">                      1   3      3</span>
<span class="sd">                      1   4      4</span>
<span class="sd">                      2   1      5</span>
<span class="sd">                      2   2      6</span>
<span class="sd">                      2   3      7</span>
<span class="sd">                      2   4      8</span>
<span class="sd">                      3   1      9</span>
<span class="sd">                      3   2      10</span>
<span class="sd">                      3   3      11</span>
<span class="sd">                      3   4      12</span>
<span class="sd">                      4   1      13</span>
<span class="sd">                      4   2      14</span>
<span class="sd">                      4   3      15</span>
<span class="sd">                      4   4      16</span>
<span class="sd">                      ==  ==     =========</span>

<span class="sd">    p            : array</span>
<span class="sd">                   (k, k), transition probability matrix.</span>
<span class="sd">    p_values     : matrix</span>
<span class="sd">                   (n, t), LISA p-values for each end point (if permutations &gt;</span>
<span class="sd">                   0).</span>
<span class="sd">    significant_moves : matrix</span>
<span class="sd">                        (n, t-1), integer values indicating the type and</span>
<span class="sd">                        significance of a LISA transition. st = 1 if</span>
<span class="sd">                        significant in period t, else st=0 (if permutations &gt;</span>
<span class="sd">                        0).</span>

<span class="sd">                        .. table:: Significant Moves1</span>

<span class="sd">                           ===============  ===================</span>
<span class="sd">                           (s1,s2)          move_type</span>
<span class="sd">                           ===============  ===================</span>
<span class="sd">                           (1,1)            [1, 16]</span>
<span class="sd">                           (1,0)            [17, 32]</span>
<span class="sd">                           (0,1)            [33, 48]</span>
<span class="sd">                           (0,0)            [49, 64]</span>
<span class="sd">                           ===============  ===================</span>

<span class="sd">                        .. table:: Significant Moves2</span>

<span class="sd">                           == ==  ==  ==  =========</span>
<span class="sd">                           q1 q2  s1  s2  move_type</span>
<span class="sd">                           == ==  ==  ==  =========</span>
<span class="sd">                           1  1   1   1   1</span>
<span class="sd">                           1  2   1   1   2</span>
<span class="sd">                           1  3   1   1   3</span>
<span class="sd">                           1  4   1   1   4</span>
<span class="sd">                           2  1   1   1   5</span>
<span class="sd">                           2  2   1   1   6</span>
<span class="sd">                           2  3   1   1   7</span>
<span class="sd">                           2  4   1   1   8</span>
<span class="sd">                           3  1   1   1   9</span>
<span class="sd">                           3  2   1   1   10</span>
<span class="sd">                           3  3   1   1   11</span>
<span class="sd">                           3  4   1   1   12</span>
<span class="sd">                           4  1   1   1   13</span>
<span class="sd">                           4  2   1   1   14</span>
<span class="sd">                           4  3   1   1   15</span>
<span class="sd">                           4  4   1   1   16</span>
<span class="sd">                           1  1   1   0   17</span>
<span class="sd">                           1  2   1   0   18</span>
<span class="sd">                           .  .   .   .    .</span>
<span class="sd">                           .  .   .   .    .</span>
<span class="sd">                           4  3   1   0   31</span>
<span class="sd">                           4  4   1   0   32</span>
<span class="sd">                           1  1   0   1   33</span>
<span class="sd">                           1  2   0   1   34</span>
<span class="sd">                           .  .   .   .    .</span>
<span class="sd">                           .  .   .   .    .</span>
<span class="sd">                           4  3   0   1   47</span>
<span class="sd">                           4  4   0   1   48</span>
<span class="sd">                           1  1   0   0   49</span>
<span class="sd">                           1  2   0   0   50</span>
<span class="sd">                           .  .   .   .    .</span>
<span class="sd">                           .  .   .   .    .</span>
<span class="sd">                           4  3   0   0   63</span>
<span class="sd">                           4  4   0   0   64</span>
<span class="sd">                           == ==  ==  ==  =========</span>

<span class="sd">    steady_state : array</span>
<span class="sd">                   (k, ), ergodic distribution.</span>
<span class="sd">    transitions  : array</span>
<span class="sd">                   (4, 4), count of transitions between each state i and j.</span>
<span class="sd">    spillover    : array</span>
<span class="sd">                   (n, 1) binary array, locations that were not part of a</span>
<span class="sd">                   cluster in period 1 but joined a prexisting cluster in</span>
<span class="sd">                   period 2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import libpysal</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from giddy.markov import LISA_Markov</span>
<span class="sd">    &gt;&gt;&gt; np.set_printoptions(suppress=True) #prevent scientific format</span>
<span class="sd">    &gt;&gt;&gt; f = libpysal.io.open(libpysal.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">    &gt;&gt;&gt; years = list(range(1929, 2010))</span>
<span class="sd">    &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in years]).transpose()</span>
<span class="sd">    &gt;&gt;&gt; w = libpysal.io.open(libpysal.examples.get_path(&quot;states48.gal&quot;)).read()</span>
<span class="sd">    &gt;&gt;&gt; lm = LISA_Markov(pci,w)</span>
<span class="sd">    &gt;&gt;&gt; lm.classes</span>
<span class="sd">    array([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; lm.steady_state</span>
<span class="sd">    array([0.28561505, 0.14190226, 0.40493672, 0.16754598])</span>
<span class="sd">    &gt;&gt;&gt; lm.transitions</span>
<span class="sd">    array([[1087.,   44.,    4.,   34.],</span>
<span class="sd">           [  41.,  470.,   36.,    1.],</span>
<span class="sd">           [   5.,   34., 1422.,   39.],</span>
<span class="sd">           [  30.,    1.,   40.,  552.]])</span>
<span class="sd">    &gt;&gt;&gt; lm.p</span>
<span class="sd">    array([[0.92985458, 0.03763901, 0.00342173, 0.02908469],</span>
<span class="sd">           [0.07481752, 0.85766423, 0.06569343, 0.00182482],</span>
<span class="sd">           [0.00333333, 0.02266667, 0.948     , 0.026     ],</span>
<span class="sd">           [0.04815409, 0.00160514, 0.06420546, 0.88603531]])</span>
<span class="sd">    &gt;&gt;&gt; lm.move_types[0,:3]</span>
<span class="sd">    array([11, 11, 11])</span>
<span class="sd">    &gt;&gt;&gt; lm.move_types[0,-3:]</span>
<span class="sd">    array([11, 11, 11])</span>

<span class="sd">    Now consider only moves with one, or both, of the LISA end points being</span>
<span class="sd">    significant</span>

<span class="sd">    &gt;&gt;&gt; np.random.seed(10)</span>
<span class="sd">    &gt;&gt;&gt; lm_random = LISA_Markov(pci, w, permutations=99)</span>
<span class="sd">    &gt;&gt;&gt; lm_random.significant_moves[0, :3]</span>
<span class="sd">    array([11, 11, 11])</span>
<span class="sd">    &gt;&gt;&gt; lm_random.significant_moves[0,-3:]</span>
<span class="sd">    array([59, 43, 27])</span>


<span class="sd">    Any value less than 49 indicates at least one of the LISA end points was</span>
<span class="sd">    significant. So for example, the first spatial unit experienced a</span>
<span class="sd">    transition of type 11 (LL, LL)  during the first three and last tree</span>
<span class="sd">    intervals (according to lm.move_types), however, the last three of these</span>
<span class="sd">    transitions involved insignificant LISAS in both the start and ending year</span>
<span class="sd">    of each transition.</span>

<span class="sd">    Test whether the moves of y are independent of the moves of wy</span>

<span class="sd">    &gt;&gt;&gt; &quot;Chi2: %8.3f, p: %5.2f, dof: %d&quot; % lm.chi_2</span>
<span class="sd">    &#39;Chi2: 1058.208, p:  0.00, dof: 9&#39;</span>

<span class="sd">    Actual transitions of LISAs</span>

<span class="sd">    &gt;&gt;&gt; lm.transitions</span>
<span class="sd">    array([[1087.,   44.,    4.,   34.],</span>
<span class="sd">           [  41.,  470.,   36.,    1.],</span>
<span class="sd">           [   5.,   34., 1422.,   39.],</span>
<span class="sd">           [  30.,    1.,   40.,  552.]])</span>

<span class="sd">    Expected transitions of LISAs under the null y and wy are moving</span>
<span class="sd">    independently of one another</span>

<span class="sd">    &gt;&gt;&gt; lm.expected_t</span>
<span class="sd">    array([[1123.2809778 ,   11.53773565,    0.34752216,   33.83376439],</span>
<span class="sd">           [   3.50272664,  528.47388155,   15.917888  ,    0.10550381],</span>
<span class="sd">           [   0.15387808,   23.21635562, 1466.90710117,    9.72266513],</span>
<span class="sd">           [   9.60775143,    0.09868563,    6.23537392,  607.05818902]])</span>

<span class="sd">    If the LISA classes are to be defined according to GeoDa, the `geoda_quad`</span>
<span class="sd">    option has to be set to true</span>

<span class="sd">    &gt;&gt;&gt; lm.q[0:5,0]</span>
<span class="sd">    array([3, 2, 3, 1, 4])</span>
<span class="sd">    &gt;&gt;&gt; lm = LISA_Markov(pci,w, geoda_quads=True)</span>
<span class="sd">    &gt;&gt;&gt; lm.q[0:5,0]</span>
<span class="sd">    array([2, 3, 2, 1, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LISA_Markov.__init__"><a class="viewcode-back" href="../../generated/giddy.markov.LISA_Markov.html#giddy.markov.LISA_Markov.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">significance_level</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">geoda_quads</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">pml</span> <span class="o">=</span> <span class="n">Moran_Local</span>
        <span class="n">gq</span> <span class="o">=</span> <span class="n">geoda_quads</span>
        <span class="n">ml</span> <span class="o">=</span> <span class="p">[</span><span class="n">pml</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">,</span> <span class="n">geoda_quads</span><span class="o">=</span><span class="n">gq</span><span class="p">)</span> <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mli</span><span class="o">.</span><span class="n">q</span> <span class="k">for</span> <span class="n">mli</span> <span class="ow">in</span> <span class="n">ml</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># no guarantee all 4 quadrants are visited</span>
        <span class="n">Markov</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significance_level</span> <span class="o">=</span> <span class="n">significance_level</span>
        <span class="n">move_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significance_level</span> <span class="o">=</span> <span class="n">significance_level</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mli</span><span class="o">.</span><span class="n">p_z_sim</span> <span class="k">for</span> <span class="n">mli</span> <span class="ow">in</span> <span class="n">ml</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">pb</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">significance_level</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">p_origin</span> <span class="o">=</span> <span class="n">pb</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
            <span class="n">p_dest</span> <span class="o">=</span> <span class="n">pb</span><span class="p">[:,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">move_types</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">origin</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">dest</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">dest</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">p_origin</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">p_dest</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
                <span class="n">sm</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">MOVE_TYPES</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">significant_moves</span> <span class="o">=</span> <span class="n">sm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">move_types</span> <span class="o">=</span> <span class="n">move_types</span>

        <span class="c1"># null of own and lag moves being independent</span>

        <span class="n">ybar</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">ybar</span>
        <span class="n">ylag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">weights</span><span class="o">.</span><span class="n">lag_spatial</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">yt</span><span class="p">)</span> <span class="k">for</span> <span class="n">yt</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>
        <span class="n">rlag</span> <span class="o">=</span> <span class="n">ylag</span> <span class="o">/</span> <span class="n">ybar</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
        <span class="n">rlagc</span> <span class="o">=</span> <span class="n">rlag</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
        <span class="n">markov_y</span> <span class="o">=</span> <span class="n">Markov</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">markov_ylag</span> <span class="o">=</span> <span class="n">Markov</span><span class="p">(</span><span class="n">rlagc</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

        <span class="n">kp</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">markov_y</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">markov_ylag</span><span class="o">.</span><span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kp</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chi_2</span> <span class="o">=</span> <span class="n">chi2</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expected_t</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permutations</span> <span class="o">=</span> <span class="n">permutations</span></div>

<div class="viewcode-block" id="LISA_Markov.spillover"><a class="viewcode-back" href="../../generated/giddy.markov.LISA_Markov.html#giddy.markov.LISA_Markov.spillover">[docs]</a>    <span class="k">def</span> <span class="nf">spillover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quadrant</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">neighbors_on</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect spillover locations for diffusion in LISA Markov.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quadrant     : int</span>
<span class="sd">                       which quadrant in the scatterplot should form the core</span>
<span class="sd">                       of a cluster.</span>
<span class="sd">        neighbors_on : binary</span>
<span class="sd">                       If false, then only the 1st order neighbors of a core</span>
<span class="sd">                       location are included in the cluster.</span>
<span class="sd">                       If true, neighbors of cluster core 1st order neighbors</span>
<span class="sd">                       are included in the cluster.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results      : dictionary</span>
<span class="sd">                       two keys - values pairs:</span>
<span class="sd">                       &#39;components&#39; - array (n, t)</span>
<span class="sd">                       values are integer ids (starting at 1) indicating which</span>
<span class="sd">                       component/cluster observation i in period t belonged to.</span>
<span class="sd">                       &#39;spillover&#39; - array (n, t-1)</span>
<span class="sd">                       binary values indicating if the location was a</span>
<span class="sd">                       spill-over location that became a new member of a</span>
<span class="sd">                       previously existing cluster.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import libpysal</span>
<span class="sd">        &gt;&gt;&gt; from giddy.markov import LISA_Markov</span>
<span class="sd">        &gt;&gt;&gt; f = libpysal.io.open(libpysal.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">        &gt;&gt;&gt; years = list(range(1929, 2010))</span>
<span class="sd">        &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in years]).transpose()</span>
<span class="sd">        &gt;&gt;&gt; w = libpysal.io.open(libpysal.examples.get_path(&quot;states48.gal&quot;)).read()</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(10)</span>
<span class="sd">        &gt;&gt;&gt; lm_random = LISA_Markov(pci, w, permutations=99)</span>
<span class="sd">        &gt;&gt;&gt; r = lm_random.spillover()</span>
<span class="sd">        &gt;&gt;&gt; (r[&#39;components&#39;][:, 12] &gt; 0).sum()</span>
<span class="sd">        17</span>
<span class="sd">        &gt;&gt;&gt; (r[&#39;components&#39;][:, 13]&gt;0).sum()</span>
<span class="sd">        23</span>
<span class="sd">        &gt;&gt;&gt; (r[&#39;spill_over&#39;][:,12]&gt;0).sum()</span>
<span class="sd">        6</span>

<span class="sd">        Including neighbors of core neighbors</span>
<span class="sd">        &gt;&gt;&gt; rn = lm_random.spillover(neighbors_on=True)</span>
<span class="sd">        &gt;&gt;&gt; (rn[&#39;components&#39;][:, 12] &gt; 0).sum()</span>
<span class="sd">        26</span>
<span class="sd">        &gt;&gt;&gt; (rn[&quot;components&quot;][:, 13] &gt; 0).sum()</span>
<span class="sd">        34</span>
<span class="sd">        &gt;&gt;&gt; (rn[&quot;spill_over&quot;][:, 12] &gt; 0).sum()</span>
<span class="sd">        8</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutations</span><span class="p">:</span>
            <span class="n">spill_over</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">i2id</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># handle string keys</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">neighbors</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">id2i</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">i2id</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">sig_lisas</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="n">quadrant</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance_level</span>
            <span class="p">)</span>
            <span class="n">sig_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sig_lisas</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">neighbors</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">sig_ids</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">sig_ids</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">g1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                        <span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">neighbor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">neighbors_on</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                                <span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">components1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">gt</span><span class="p">)</span>
                <span class="n">components1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components1</span><span class="p">]</span>
                <span class="n">g2</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s2</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                        <span class="n">g2</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">neighbor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">neighbors_on</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                                <span class="n">g2</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">components2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">gt</span><span class="p">)</span>
                <span class="n">components2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components2</span><span class="p">]</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components2</span><span class="p">:</span>
                    <span class="n">c2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components1</span><span class="p">:</span>
                    <span class="n">c1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

                <span class="n">new_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">c2</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c1</span><span class="p">]</span>
                <span class="n">spill_ids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">new_ids</span><span class="p">:</span>
                    <span class="c1"># find j&#39;s component in period 2</span>
                    <span class="n">cj</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components2</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># for members of j&#39;s component in period 2, check if they</span>
                    <span class="c1"># belonged to any components in period 1</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cj</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c1</span><span class="p">:</span>
                            <span class="n">spill_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="k">break</span>
                <span class="k">for</span> <span class="n">spill_id</span> <span class="ow">in</span> <span class="n">spill_ids</span><span class="p">:</span>
                    <span class="nb">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">id2i</span><span class="p">[</span><span class="n">spill_id</span><span class="p">]</span>
                    <span class="n">spill_over</span><span class="p">[</span><span class="nb">id</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
                        <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">id2i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">components</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">components</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;spill_over&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spill_over</span>
            <span class="k">return</span> <span class="n">results</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="kullback"><a class="viewcode-back" href="../../generated/giddy.markov.kullback.html#giddy.markov.kullback">[docs]</a><span class="k">def</span> <span class="nf">kullback</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kullback information based test of Markov Homogeneity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : array</span>
<span class="sd">        (s, r, r), values are transitions (not probabilities) for</span>
<span class="sd">        s strata, r initial states, r terminal states.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Results : dictionary</span>
<span class="sd">              (key - value)</span>

<span class="sd">              Conditional homogeneity - (float) test statistic for homogeneity</span>
<span class="sd">              of transition probabilities across strata.</span>

<span class="sd">              Conditional homogeneity pvalue - (float) p-value for test</span>
<span class="sd">              statistic.</span>

<span class="sd">              Conditional homogeneity dof - (int) degrees of freedom =</span>
<span class="sd">              r(s-1)(r-1).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on :cite:`Kullback1962`.</span>
<span class="sd">    Example below is taken from Table 9.2 .</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from giddy.markov import kullback</span>
<span class="sd">    &gt;&gt;&gt; s1 = np.array([</span>
<span class="sd">    ...         [ 22, 11, 24,  2,  2,  7],</span>
<span class="sd">    ...         [ 5, 23, 15,  3, 42,  6],</span>
<span class="sd">    ...         [ 4, 21, 190, 25, 20, 34],</span>
<span class="sd">    ...         [0, 2, 14, 56, 14, 28],</span>
<span class="sd">    ...         [32, 15, 20, 10, 56, 14],</span>
<span class="sd">    ...         [5, 22, 31, 18, 13, 134]</span>
<span class="sd">    ...     ])</span>
<span class="sd">    &gt;&gt;&gt; s2 = np.array([</span>
<span class="sd">    ...     [3, 6, 9, 3, 0, 8],</span>
<span class="sd">    ...     [1, 9, 3, 12, 27, 5],</span>
<span class="sd">    ...     [2, 9, 208, 32, 5, 18],</span>
<span class="sd">    ...     [0, 14, 32, 108, 40, 40],</span>
<span class="sd">    ...     [22, 14, 9, 26, 224, 14],</span>
<span class="sd">    ...     [1, 5, 13, 53, 13, 116]</span>
<span class="sd">    ...     ])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; F = np.array([s1, s2])</span>
<span class="sd">    &gt;&gt;&gt; res = kullback(F)</span>
<span class="sd">    &gt;&gt;&gt; &quot;%8.3f&quot;%res[&#39;Conditional homogeneity&#39;]</span>
<span class="sd">    &#39; 160.961&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%d&quot;%res[&#39;Conditional homogeneity dof&#39;]</span>
<span class="sd">    &#39;30&#39;</span>
<span class="sd">    &gt;&gt;&gt; &quot;%3.1f&quot;%res[&#39;Conditional homogeneity pvalue&#39;]</span>
<span class="sd">    &#39;0.0&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">F1</span> <span class="o">=</span> <span class="n">F</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="n">F</span> <span class="o">+</span> <span class="n">F1</span>
    <span class="n">FLF</span> <span class="o">=</span> <span class="n">F</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FLF</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">FdJK</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">FdJK1</span> <span class="o">=</span> <span class="n">FdJK</span> <span class="o">+</span> <span class="p">(</span><span class="n">FdJK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">FdJKLFdJK</span> <span class="o">=</span> <span class="n">FdJK</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">FdJK1</span><span class="p">)</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FdJKLFdJK</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">FdJd</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">FdJd1</span> <span class="o">=</span> <span class="n">FdJd</span> <span class="o">+</span> <span class="p">(</span><span class="n">FdJd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">T3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">FdJd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">FdJd1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">FIJd</span> <span class="o">=</span> <span class="n">F</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">FIJd1</span> <span class="o">=</span> <span class="n">FIJd</span> <span class="o">+</span> <span class="p">(</span><span class="n">FIJd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">T4</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">FIJd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">FIJd1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">T6</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T6</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">T6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T6</span><span class="p">)</span>

    <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">chom</span> <span class="o">=</span> <span class="n">T1</span> <span class="o">-</span> <span class="n">T4</span> <span class="o">-</span> <span class="n">T2</span> <span class="o">+</span> <span class="n">T3</span>
    <span class="n">cdof</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;Conditional homogeneity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chom</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;Conditional homogeneity dof&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdof</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;Conditional homogeneity pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chom</span><span class="p">,</span> <span class="n">cdof</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="prais"><a class="viewcode-back" href="../../generated/giddy.markov.prais.html#giddy.markov.prais">[docs]</a><span class="k">def</span> <span class="nf">prais</span><span class="p">(</span><span class="n">pmat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prais conditional mobility measure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pmat : matrix</span>
<span class="sd">           (k, k), Markov probability transition matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pr   : matrix</span>
<span class="sd">           (1, k), conditional mobility measures for each of the k classes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Prais&#39; conditional mobility measure for a class is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">            pr_i = 1 -  p_{i,i}</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import libpysal</span>
<span class="sd">    &gt;&gt;&gt; from giddy.markov import Markov,prais</span>
<span class="sd">    &gt;&gt;&gt; f = libpysal.io.open(libpysal.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">    &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in range(1929,2010)])</span>
<span class="sd">    &gt;&gt;&gt; q5 = np.array([mc.Quantiles(y).yb for y in pci]).transpose()</span>
<span class="sd">    &gt;&gt;&gt; m = Markov(q5, summary=False)</span>
<span class="sd">    &gt;&gt;&gt; m.transitions</span>
<span class="sd">    array([[729.,  71.,   1.,   0.,   0.],</span>
<span class="sd">           [ 72., 567.,  80.,   3.,   0.],</span>
<span class="sd">           [  0.,  81., 631.,  86.,   2.],</span>
<span class="sd">           [  0.,   3.,  86., 573.,  56.],</span>
<span class="sd">           [  0.,   0.,   1.,  57., 741.]])</span>
<span class="sd">    &gt;&gt;&gt; m.p</span>
<span class="sd">    array([[0.91011236, 0.0886392 , 0.00124844, 0.        , 0.        ],</span>
<span class="sd">           [0.09972299, 0.78531856, 0.11080332, 0.00415512, 0.        ],</span>
<span class="sd">           [0.        , 0.10125   , 0.78875   , 0.1075    , 0.0025    ],</span>
<span class="sd">           [0.        , 0.00417827, 0.11977716, 0.79805014, 0.07799443],</span>
<span class="sd">           [0.        , 0.        , 0.00125156, 0.07133917, 0.92740926]])</span>
<span class="sd">    &gt;&gt;&gt; prais(m.p)</span>
<span class="sd">    array([0.08988764, 0.21468144, 0.21125   , 0.20194986, 0.07259074])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pmat</span><span class="p">)</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pmat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pr</span></div>


<div class="viewcode-block" id="homogeneity"><a class="viewcode-back" href="../../generated/giddy.markov.homogeneity.html#giddy.markov.homogeneity">[docs]</a><span class="k">def</span> <span class="nf">homogeneity</span><span class="p">(</span>
    <span class="n">transition_matrices</span><span class="p">,</span>
    <span class="n">regime_names</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">class_names</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Markov Homogeneity Test&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test for homogeneity of Markov transition probabilities across regimes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transition_matrices : list</span>
<span class="sd">                          of transition matrices for regimes, all matrices must</span>
<span class="sd">                          have same size (r, c). r is the number of rows in the</span>
<span class="sd">                          transition matrix and c is the number of columns in</span>
<span class="sd">                          the transition matrix.</span>
<span class="sd">    regime_names        : sequence</span>
<span class="sd">                          Labels for the regimes.</span>
<span class="sd">    class_names         : sequence</span>
<span class="sd">                          Labels for the classes/states of the Markov chain.</span>
<span class="sd">    title               : string</span>
<span class="sd">                          name of test.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">                        : implicit</span>
<span class="sd">                          an instance of Homogeneity_Results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">Homogeneity_Results</span><span class="p">(</span>
        <span class="n">transition_matrices</span><span class="p">,</span>
        <span class="n">regime_names</span><span class="o">=</span><span class="n">regime_names</span><span class="p">,</span>
        <span class="n">class_names</span><span class="o">=</span><span class="n">class_names</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Homogeneity_Results</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper class to present homogeneity results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transition_matrices : list</span>
<span class="sd">                          of transition matrices for regimes, all matrices must</span>
<span class="sd">                          have same size (r, c). r is the number of rows in</span>
<span class="sd">                          the transition matrix and c is the number of columns</span>
<span class="sd">                          in the transition matrix.</span>
<span class="sd">    regime_names        : sequence</span>
<span class="sd">                          Labels for the regimes.</span>
<span class="sd">    class_names         : sequence</span>
<span class="sd">                          Labels for the classes/states of the Markov chain.</span>
<span class="sd">    title               : string</span>
<span class="sd">                          Title of the table.</span>

<span class="sd">    Attributes</span>
<span class="sd">    -----------</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Degrees of freedom adjustment follow the approach in :cite:`Bickenbach2003`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See Spatial_Markov above.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transition_matrices</span><span class="p">,</span>
        <span class="n">regime_names</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">class_names</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Markov Homogeneity Test&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_homogeneity</span><span class="p">(</span><span class="n">transition_matrices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regime_names</span> <span class="o">=</span> <span class="n">regime_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span> <span class="o">=</span> <span class="n">class_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>

    <span class="k">def</span> <span class="nf">_homogeneity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_matrices</span><span class="p">):</span>
        <span class="c1"># form null transition probability matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transition_matrices</span><span class="p">)</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_total</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_i</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">p_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_i</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)),</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">p_ij</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_ij</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">b_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A_i</span><span class="p">)</span>
        <span class="n">p_ijm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="c1"># get dimensions</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">LR</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">lr_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">q_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nijm</span> <span class="ow">in</span> <span class="n">M</span><span class="p">:</span>
            <span class="n">nim</span> <span class="o">=</span> <span class="n">nijm</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">B</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">nim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">b_i</span> <span class="o">=</span> <span class="n">b_i</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">nim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p_ijm</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">nim</span> <span class="o">+</span> <span class="p">(</span><span class="n">nim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)),</span> <span class="n">nijm</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_ijm</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">p_ij</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
            <span class="n">qijm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nim</span><span class="p">),</span> <span class="n">ratio</span><span class="p">)</span>
            <span class="n">q_table</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">qijm</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">qijm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># only use nonzero pijm in lr test</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">nijm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_ij</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">A_im</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nijm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">unmask</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">*</span> <span class="n">p_ijm</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">unmask</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mask</span> <span class="o">*</span> <span class="n">p_ij</span> <span class="o">+</span> <span class="n">unmask</span><span class="p">)</span>
            <span class="n">lr</span> <span class="o">=</span> <span class="n">nijm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
            <span class="n">LR</span> <span class="o">=</span> <span class="n">LR</span> <span class="o">+</span> <span class="n">lr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">lr_table</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lr</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># b_i is the number of regimes that have non-zero observations in row i</span>
        <span class="c1"># A_i is the number of non-zero elements in row i of the aggregated</span>
        <span class="c1"># transition matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(((</span><span class="n">b_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">A_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q_p_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LR</span> <span class="o">=</span> <span class="n">LR</span> <span class="o">*</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LR_p_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">LR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A_i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_im</span> <span class="o">=</span> <span class="n">A_im</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_i</span> <span class="o">=</span> <span class="n">b_i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LR_table</span> <span class="o">=</span> <span class="n">lr_table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q_table</span> <span class="o">=</span> <span class="n">q_table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_h0</span> <span class="o">=</span> <span class="n">p_ij</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_h1</span> <span class="o">=</span> <span class="n">p_ijm</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Markov Homogeneity Test&quot;</span><span class="p">):</span>
        <span class="n">regime_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_names</span><span class="p">:</span>
            <span class="n">regime_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_names</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;P(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">regime</span><span class="p">)</span> <span class="k">for</span> <span class="n">regime</span> <span class="ow">in</span> <span class="n">regime_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>

        <span class="n">max_col</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">])</span>
        <span class="n">col_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_col</span><span class="p">])</span>  <span class="c1"># probabilities have 5 chars</span>
        <span class="n">n_tabs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">n_tabs</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">col_width</span>
        <span class="n">lead</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">width</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">title</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="p">[</span><span class="n">lead</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">lead</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="s2">&quot;Number of regimes: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="s2">&quot;Number of classes: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="s2">&quot;Regime names: &quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">regime_names</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;Number of transitions: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_total</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lead</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%7s</span><span class="s2"> </span><span class="si">%20s</span><span class="s2"> </span><span class="si">%20s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;Test&quot;</span><span class="p">,</span> <span class="s2">&quot;LR&quot;</span><span class="p">,</span> <span class="s2">&quot;Chi-2&quot;</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%7s</span><span class="s2"> </span><span class="si">%20.3f</span><span class="s2"> </span><span class="si">%20.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;Stat.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">LR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%7s</span><span class="s2"> </span><span class="si">%20d</span><span class="s2"> </span><span class="si">%20d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;DOF&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%7s</span><span class="s2"> </span><span class="si">%20.3f</span><span class="s2"> </span><span class="si">%20.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;p-value&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">LR_p_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_p_value</span><span class="p">)</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">contents</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">lead</span><span class="p">)</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;P(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">regime</span><span class="p">)</span> <span class="k">for</span> <span class="n">regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>
        <span class="n">cols</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span> <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span><span class="p">])</span>

        <span class="n">max_col</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">])</span>
        <span class="n">col_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_col</span><span class="p">])</span>  <span class="c1"># probabilities have 5 chars</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line0</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;{s: &lt;</span><span class="si">{w}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="s2">&quot;P(H0)&quot;</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">col_width</span><span class="p">)]</span>
        <span class="n">line0</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">([</span><span class="s2">&quot;{s: &gt;</span><span class="si">{w}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">cname</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">col_width</span><span class="p">)</span> <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line0</span><span class="p">)))</span>
        <span class="n">p0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_h0</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%*s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">col_width</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))]</span>
            <span class="n">line</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%*.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">col_width</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">)))</span>
            <span class="n">p0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="n">pmats</span> <span class="o">=</span> <span class="p">[</span><span class="n">p0</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">lead</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">p1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_h1</span><span class="p">):</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">line0</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;{s: &lt;</span><span class="si">{w}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="s2">&quot;P(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">regime_names</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">w</span><span class="o">=</span><span class="n">col_width</span><span class="p">)]</span>
            <span class="n">line0</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">[</span>
                        <span class="s2">&quot;{s: &gt;</span><span class="si">{w}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">cname</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">col_width</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line0</span><span class="p">)))</span>
            <span class="n">p0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line0</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p1</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%*s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">col_width</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))]</span>
                <span class="n">line</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%*.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">col_width</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">)))</span>
                <span class="n">p0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="n">pmats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">lead</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_name</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">begin</span><span class="si">{tabular}</span><span class="s2">{|</span><span class="si">%s</span><span class="s2">|}</span><span class="se">\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fmt</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">multicolumn{</span><span class="si">%s</span><span class="s2">}{|c|}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Number of classes: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">hline</span><span class="se">\\</span><span class="s2">multicolumn{</span><span class="si">%s</span><span class="s2">}{|l|}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Number of transitions: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_total</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">multicolumn{</span><span class="si">%s</span><span class="s2">}{|l|}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Number of regimes: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">multicolumn{</span><span class="si">%s</span><span class="s2">}{|l|}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Regime names: &quot;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">regime_names</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">multicolumn{</span><span class="si">%s</span><span class="s2">}{|l|}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">hline</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{|l}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;Test&quot;</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}{r}{LR}</span><span class="s2">&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{r|}</span><span class="si">{Q}</span><span class="s2">&quot;</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Stat.&quot;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{|l}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}{r}</span><span class="s2">{</span><span class="si">%.3f</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">LR</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{r|}{</span><span class="si">%.3f</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{|l}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;DOF&quot;</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}{r}</span><span class="s2">{</span><span class="si">%d</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{r|}{</span><span class="si">%d</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{|l}{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;p-value&quot;</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}{r}</span><span class="s2">{</span><span class="si">%.3f</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">LR_p_value</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&amp;</span><span class="se">\\</span><span class="s2">multicolumn</span><span class="si">{2}</span><span class="s2">{r|}{</span><span class="si">%.3f</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_p_value</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\\\\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">s1</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\\\\n</span><span class="s2">&quot;</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">mat</span> <span class="ow">in</span> <span class="n">pmats</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\\\\\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">end</span><span class="si">{tabular}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">)</span>


<div class="viewcode-block" id="FullRank_Markov"><a class="viewcode-back" href="../../generated/giddy.markov.FullRank_Markov.html#giddy.markov.FullRank_Markov">[docs]</a><span class="k">class</span> <span class="nc">FullRank_Markov</span><span class="p">(</span><span class="n">Markov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Full Rank Markov in which ranks are considered as Markov states rather</span>
<span class="sd">    than quantiles or other discretized classes. This is one way to avoid</span>
<span class="sd">    issues associated with discretization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y            : array</span>
<span class="sd">                   (n, t) with t&gt;&gt;n, one row per observation (n total),</span>
<span class="sd">                   one column recording the value of each observation,</span>
<span class="sd">                   with as many columns as time periods.</span>
<span class="sd">    fill_empty_classes: bool</span>
<span class="sd">                        If True, assign 1 to diagonal elements which fall in rows</span>
<span class="sd">                        full of 0s to ensure p is a stochastic transition</span>
<span class="sd">                        probability matrix (each row sums up to 1).</span>
<span class="sd">    summary      : bool</span>
<span class="sd">                   If True, print out the summary of the Markov Chain during</span>
<span class="sd">                   initialization. Default is True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ranks        : array</span>
<span class="sd">                   ranks of the original y array (by columns): higher values</span>
<span class="sd">                   rank higher, e.g. the largest value in a column ranks 1.</span>
<span class="sd">    p            : array</span>
<span class="sd">                   (n, n), transition probability matrix for Full</span>
<span class="sd">                   Rank Markov.</span>
<span class="sd">    steady_state : array</span>
<span class="sd">                   (n, ), ergodic distribution.</span>
<span class="sd">    transitions  : array</span>
<span class="sd">                   (n, n), count of transitions between each rank i and j</span>
<span class="sd">    fmpt         : array</span>
<span class="sd">                   (n, n), first mean passage times.</span>
<span class="sd">    sojourn_time : array</span>
<span class="sd">                   (n, ), sojourn times.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Refer to :cite:`Rey2014a` Equation (11) for details. Ties are resolved by</span>
<span class="sd">    assigning distinct ranks, corresponding to the order that the values occur</span>
<span class="sd">    in each cross section.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    US nominal per capita income 48 states 81 years 1929-2009</span>

<span class="sd">    &gt;&gt;&gt; from giddy.markov import FullRank_Markov</span>
<span class="sd">    &gt;&gt;&gt; import libpysal as ps</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; f = ps.io.open(ps.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">    &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in range(1929,2010)]).transpose()</span>
<span class="sd">    &gt;&gt;&gt; m = FullRank_Markov(pci)</span>
<span class="sd">    The Markov Chain is irreducible and is composed by:</span>
<span class="sd">    1 Recurrent class (indices):</span>
<span class="sd">    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span>
<span class="sd">     24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47]</span>
<span class="sd">    0 Transient classes.</span>
<span class="sd">    The Markov Chain has 0 absorbing states.</span>
<span class="sd">    &gt;&gt;&gt; m.transitions</span>
<span class="sd">    array([[66.,  5.,  5., ...,  0.,  0.,  0.],</span>
<span class="sd">           [ 8., 51.,  9., ...,  0.,  0.,  0.],</span>
<span class="sd">           [ 2., 13., 44., ...,  0.,  0.,  0.],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.,  0.,  0., ..., 40., 17.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0., ..., 15., 54.,  2.],</span>
<span class="sd">           [ 0.,  0.,  0., ...,  2.,  1., 77.]])</span>
<span class="sd">    &gt;&gt;&gt; m.p[0, :5]</span>
<span class="sd">    array([0.825 , 0.0625, 0.0625, 0.025 , 0.025 ])</span>
<span class="sd">    &gt;&gt;&gt; m.fmpt[0, :5]</span>
<span class="sd">    array([48.        , 87.96280048, 68.1089084 , 58.83306575, 41.77250827])</span>
<span class="sd">    &gt;&gt;&gt; m.sojourn_time[:5]</span>
<span class="sd">    array([5.71428571, 2.75862069, 2.22222222, 1.77777778, 1.66666667])</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FullRank_Markov.__init__"><a class="viewcode-back" href="../../generated/giddy.markov.FullRank_Markov.html#giddy.markov.FullRank_Markov.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># resolve ties: All values are given a distinct rank, corresponding</span>
        <span class="c1"># to the order that the values occur in each cross section.</span>
        <span class="n">r_asc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rankdata</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ordinal&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># ranks by high (1) to low (n)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span> <span class="o">=</span> <span class="n">r_asc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r_asc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FullRank_Markov</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="n">fill_empty_classes</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="n">summary</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="sojourn_time"><a class="viewcode-back" href="../../generated/giddy.markov.sojourn_time.html#giddy.markov.sojourn_time">[docs]</a><span class="k">def</span> <span class="nf">sojourn_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate sojourn time based on a given transition probability matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p        : array</span>
<span class="sd">               (k, k), a Markov transition probability matrix.</span>
<span class="sd">    summary  : bool</span>
<span class="sd">               If True and the Markov Chain has absorbing states whose</span>
<span class="sd">               sojourn time is infinitely large, print out the information</span>
<span class="sd">               about the absorbing states. Default is True.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">             : array</span>
<span class="sd">               (k, ), sojourn times. Each element is the expected time a Markov</span>
<span class="sd">               chain spends in each state before leaving that state.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Refer to :cite:`Ibe2009` for more details on sojourn times for Markov</span>
<span class="sd">    chains.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from giddy.markov import sojourn_time</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; p = np.array([[.5, .25, .25], [.5, 0, .5], [.25, .25, .5]])</span>
<span class="sd">    &gt;&gt;&gt; sojourn_time(p)</span>
<span class="sd">    array([2., 1., 2.])</span>

<span class="sd">    Non-ergodic Markov Chains with rows full of 0</span>

<span class="sd">    &gt;&gt;&gt; p = np.array([[.5, .25, .25], [.5, 0, .5],[ 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; sojourn_time(p)</span>
<span class="sd">    Sojourn times are infinite for absorbing states! In this Markov Chain, states [2] are absorbing states.</span>
<span class="sd">    array([ 2.,  1., inf])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">fill_empty_diagonals</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">markovchain</span> <span class="o">=</span> <span class="n">qe</span><span class="o">.</span><span class="n">MarkovChain</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">pii</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pii</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">absorbing_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pii</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">non_absorbing_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pii</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pii</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Sojourn times are infinite for absorbing states! In this &quot;</span>
                <span class="s2">&quot;Markov Chain, states </span><span class="si">{}</span><span class="s2"> are absorbing states.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">absorbing_states</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">st</span><span class="p">[</span><span class="n">non_absorbing_states</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pii</span><span class="p">[</span><span class="n">non_absorbing_states</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">st</span></div>


<div class="viewcode-block" id="GeoRank_Markov"><a class="viewcode-back" href="../../generated/giddy.markov.GeoRank_Markov.html#giddy.markov.GeoRank_Markov">[docs]</a><span class="k">class</span> <span class="nc">GeoRank_Markov</span><span class="p">(</span><span class="n">Markov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Geographic Rank Markov.</span>
<span class="sd">    Geographic units are considered as Markov states.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y            : array</span>
<span class="sd">                   (n, t) with t&gt;&gt;n, one row per observation (n total),</span>
<span class="sd">                   one column recording the value of each observation,</span>
<span class="sd">                   with as many columns as time periods.</span>
<span class="sd">    fill_empty_classes: bool</span>
<span class="sd">                        If True, assign 1 to diagonal elements which fall in rows</span>
<span class="sd">                        full of 0s to ensure p is a stochastic transition</span>
<span class="sd">                        probability matrix (each row sums up to 1).</span>
<span class="sd">    summary      : bool</span>
<span class="sd">                   If True, print out the summary of the Markov Chain during</span>
<span class="sd">                   initialization. Default is True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    p            : array</span>
<span class="sd">                   (n, n), transition probability matrix for</span>
<span class="sd">                   geographic rank Markov.</span>
<span class="sd">    steady_state : array</span>
<span class="sd">                   (n, ), ergodic distribution.</span>
<span class="sd">    transitions  : array</span>
<span class="sd">                   (n, n), count of rank transitions between each</span>
<span class="sd">                   geographic unit i and j.</span>
<span class="sd">    fmpt         : array</span>
<span class="sd">                   (n, n), first mean passage times.</span>
<span class="sd">    sojourn_time : array</span>
<span class="sd">                   (n, ), sojourn times.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Refer to :cite:`Rey2014a` Equation (13)-(16) for details. Ties are</span>
<span class="sd">    resolved by assigning distinct ranks, corresponding to the order</span>
<span class="sd">    that the values occur in each cross section.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    US nominal per capita income 48 states 81 years 1929-2009</span>

<span class="sd">    &gt;&gt;&gt; from giddy.markov import GeoRank_Markov</span>
<span class="sd">    &gt;&gt;&gt; import libpysal as ps</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; f = ps.io.open(ps.examples.get_path(&quot;usjoin.csv&quot;))</span>
<span class="sd">    &gt;&gt;&gt; pci = np.array([f.by_col[str(y)] for y in range(1929,2010)]).transpose()</span>
<span class="sd">    &gt;&gt;&gt; m = GeoRank_Markov(pci)</span>
<span class="sd">    The Markov Chain is irreducible and is composed by:</span>
<span class="sd">    1 Recurrent class (indices):</span>
<span class="sd">    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span>
<span class="sd">     24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47]</span>
<span class="sd">    0 Transient classes.</span>
<span class="sd">    The Markov Chain has 0 absorbing states.</span>
<span class="sd">    &gt;&gt;&gt; m.transitions</span>
<span class="sd">    array([[38.,  0.,  8., ...,  0.,  0.,  0.],</span>
<span class="sd">           [ 0., 15.,  0., ...,  0.,  1.,  0.],</span>
<span class="sd">           [ 6.,  0., 44., ...,  5.,  0.,  0.],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 2.,  0.,  5., ..., 34.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0., ...,  0., 18.,  2.],</span>
<span class="sd">           [ 0.,  0.,  0., ...,  0.,  3., 14.]])</span>
<span class="sd">    &gt;&gt;&gt; m.p</span>
<span class="sd">    array([[0.475 , 0.    , 0.1   , ..., 0.    , 0.    , 0.    ],</span>
<span class="sd">           [0.    , 0.1875, 0.    , ..., 0.    , 0.0125, 0.    ],</span>
<span class="sd">           [0.075 , 0.    , 0.55  , ..., 0.0625, 0.    , 0.    ],</span>
<span class="sd">           ...,</span>
<span class="sd">           [0.025 , 0.    , 0.0625, ..., 0.425 , 0.    , 0.    ],</span>
<span class="sd">           [0.    , 0.    , 0.    , ..., 0.    , 0.225 , 0.025 ],</span>
<span class="sd">           [0.    , 0.    , 0.    , ..., 0.    , 0.0375, 0.175 ]])</span>
<span class="sd">    &gt;&gt;&gt; m.fmpt</span>
<span class="sd">    array([[ 48.        ,  63.35532038,  92.75274652, ...,  82.47515731,</span>
<span class="sd">             71.01114491,  68.65737127],</span>
<span class="sd">           [108.25928005,  48.        , 127.99032986, ...,  92.03098299,</span>
<span class="sd">             63.36652935,  61.82733039],</span>
<span class="sd">           [ 76.96801786,  64.7713783 ,  48.        , ...,  73.84595169,</span>
<span class="sd">             72.24682723,  69.77497173],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 93.3107474 ,  62.47670463, 105.80634118, ...,  48.        ,</span>
<span class="sd">             69.30121319,  67.08838421],</span>
<span class="sd">           [113.65278078,  61.1987031 , 133.57991745, ...,  96.0103924 ,</span>
<span class="sd">             48.        ,  56.74165107],</span>
<span class="sd">           [114.71894813,  63.4019776 , 134.73381719, ...,  97.287895  ,</span>
<span class="sd">             61.45565054,  48.        ]])</span>
<span class="sd">    &gt;&gt;&gt; m.sojourn_time</span>
<span class="sd">    array([ 1.9047619 ,  1.23076923,  2.22222222,  1.73913043,  1.15942029,</span>
<span class="sd">            3.80952381,  1.70212766,  1.25      ,  1.31147541,  1.11111111,</span>
<span class="sd">            1.73913043,  1.37931034,  1.17647059,  1.21212121,  1.33333333,</span>
<span class="sd">            1.37931034,  1.09589041,  2.10526316,  2.        ,  1.45454545,</span>
<span class="sd">            1.26984127, 26.66666667,  1.19402985,  1.23076923,  1.09589041,</span>
<span class="sd">            1.56862745,  1.26984127,  2.42424242,  1.50943396,  2.        ,</span>
<span class="sd">            1.29032258,  1.09589041,  1.6       ,  1.42857143,  1.25      ,</span>
<span class="sd">            1.45454545,  1.29032258,  1.6       ,  1.17647059,  1.56862745,</span>
<span class="sd">            1.25      ,  1.37931034,  1.45454545,  1.42857143,  1.29032258,</span>
<span class="sd">            1.73913043,  1.29032258,  1.21212121])</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GeoRank_Markov.__init__"><a class="viewcode-back" href="../../generated/giddy.markov.GeoRank_Markov.html#giddy.markov.GeoRank_Markov.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># resolve ties: All values are given a distinct rank, corresponding</span>
        <span class="c1"># to the order that the values occur in each cross section.</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rankdata</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ordinal&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">geo_ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GeoRank_Markov</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">geo_ranks</span><span class="p">,</span> <span class="n">fill_empty_classes</span><span class="o">=</span><span class="n">fill_empty_classes</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="n">summary</span>
        <span class="p">)</span></div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.4.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>